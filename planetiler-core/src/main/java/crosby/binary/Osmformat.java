// Code generated by protocol buffer compiler. Do not edit!
package crosby.binary;

import java.io.IOException;
import java.util.List;
import us.hebi.quickbuf.FieldName;
import us.hebi.quickbuf.InvalidProtocolBufferException;
import us.hebi.quickbuf.JsonSink;
import us.hebi.quickbuf.JsonSource;
import us.hebi.quickbuf.MessageFactory;
import us.hebi.quickbuf.ProtoEnum;
import us.hebi.quickbuf.ProtoMessage;
import us.hebi.quickbuf.ProtoSink;
import us.hebi.quickbuf.ProtoSource;
import us.hebi.quickbuf.ProtoUtil;
import us.hebi.quickbuf.RepeatedBoolean;
import us.hebi.quickbuf.RepeatedBytes;
import us.hebi.quickbuf.RepeatedEnum;
import us.hebi.quickbuf.RepeatedInt;
import us.hebi.quickbuf.RepeatedLong;
import us.hebi.quickbuf.RepeatedMessage;
import us.hebi.quickbuf.RepeatedString;
import us.hebi.quickbuf.UninitializedMessageException;
import us.hebi.quickbuf.Utf8String;

public final class Osmformat {
  public static final class HeaderBlock extends ProtoMessage<HeaderBlock> implements Cloneable {
    private static final long serialVersionUID = 0L;

    /**
     * optional int64 osmosis_replication_timestamp = 32;
     */
    private long osmosisReplicationTimestamp;

    /**
     * optional int64 osmosis_replication_sequence_number = 33;
     */
    private long osmosisReplicationSequenceNumber;

    /**
     * optional .OSMPBF.HeaderBBox bbox = 1;
     */
    private final HeaderBBox bbox = HeaderBBox.newInstance();

    /**
     * optional string writingprogram = 16;
     */
    private final Utf8String writingprogram = Utf8String.newEmptyInstance();

    /**
     * optional string source = 17;
     */
    private final Utf8String source = Utf8String.newEmptyInstance();

    /**
     * optional string osmosis_replication_base_url = 34;
     */
    private final Utf8String osmosisReplicationBaseUrl = Utf8String.newEmptyInstance();

    /**
     * repeated string required_features = 4;
     */
    private final RepeatedString requiredFeatures = RepeatedString.newEmptyInstance();

    /**
     * repeated string optional_features = 5;
     */
    private final RepeatedString optionalFeatures = RepeatedString.newEmptyInstance();

    private HeaderBlock() {
    }

    public static HeaderBlock newInstance() {
      return new HeaderBlock();
    }

    public boolean hasOsmosisReplicationTimestamp() {
      return (bitField0_ & 0x00000001) != 0;
    }

    public HeaderBlock clearOsmosisReplicationTimestamp() {
      bitField0_ &= ~0x00000001;
      osmosisReplicationTimestamp = 0L;
      return this;
    }

    public long getOsmosisReplicationTimestamp() {
      return osmosisReplicationTimestamp;
    }

    public HeaderBlock setOsmosisReplicationTimestamp(final long value) {
      bitField0_ |= 0x00000001;
      osmosisReplicationTimestamp = value;
      return this;
    }

    public boolean hasOsmosisReplicationSequenceNumber() {
      return (bitField0_ & 0x00000002) != 0;
    }

    public HeaderBlock clearOsmosisReplicationSequenceNumber() {
      bitField0_ &= ~0x00000002;
      osmosisReplicationSequenceNumber = 0L;
      return this;
    }

    public long getOsmosisReplicationSequenceNumber() {
      return osmosisReplicationSequenceNumber;
    }

    public HeaderBlock setOsmosisReplicationSequenceNumber(final long value) {
      bitField0_ |= 0x00000002;
      osmosisReplicationSequenceNumber = value;
      return this;
    }

    public boolean hasBbox() {
      return (bitField0_ & 0x00000004) != 0;
    }

    public HeaderBlock clearBbox() {
      bitField0_ &= ~0x00000004;
      bbox.clear();
      return this;
    }

    /**
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableBbox()} if you want to modify it.
     */
    public HeaderBBox getBbox() {
      return bbox;
    }

    /**
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     */
    public HeaderBBox getMutableBbox() {
      bitField0_ |= 0x00000004;
      return bbox;
    }

    public HeaderBlock setBbox(final HeaderBBox value) {
      bitField0_ |= 0x00000004;
      bbox.copyFrom(value);
      return this;
    }

    public boolean hasWritingprogram() {
      return (bitField0_ & 0x00000008) != 0;
    }

    public HeaderBlock clearWritingprogram() {
      bitField0_ &= ~0x00000008;
      writingprogram.clear();
      return this;
    }

    public String getWritingprogram() {
      return writingprogram.getString();
    }

    public Utf8String getWritingprogramBytes() {
      return this.writingprogram;
    }

    public Utf8String getMutableWritingprogramBytes() {
      bitField0_ |= 0x00000008;
      return this.writingprogram;
    }

    public HeaderBlock setWritingprogram(final CharSequence value) {
      bitField0_ |= 0x00000008;
      writingprogram.copyFrom(value);
      return this;
    }

    public boolean hasSource() {
      return (bitField0_ & 0x00000010) != 0;
    }

    public HeaderBlock clearSource() {
      bitField0_ &= ~0x00000010;
      source.clear();
      return this;
    }

    public String getSource() {
      return source.getString();
    }

    public Utf8String getSourceBytes() {
      return this.source;
    }

    public Utf8String getMutableSourceBytes() {
      bitField0_ |= 0x00000010;
      return this.source;
    }

    public HeaderBlock setSource(final CharSequence value) {
      bitField0_ |= 0x00000010;
      source.copyFrom(value);
      return this;
    }

    public boolean hasOsmosisReplicationBaseUrl() {
      return (bitField0_ & 0x00000020) != 0;
    }

    public HeaderBlock clearOsmosisReplicationBaseUrl() {
      bitField0_ &= ~0x00000020;
      osmosisReplicationBaseUrl.clear();
      return this;
    }

    public String getOsmosisReplicationBaseUrl() {
      return osmosisReplicationBaseUrl.getString();
    }

    public Utf8String getOsmosisReplicationBaseUrlBytes() {
      return this.osmosisReplicationBaseUrl;
    }

    public Utf8String getMutableOsmosisReplicationBaseUrlBytes() {
      bitField0_ |= 0x00000020;
      return this.osmosisReplicationBaseUrl;
    }

    public HeaderBlock setOsmosisReplicationBaseUrl(final CharSequence value) {
      bitField0_ |= 0x00000020;
      osmosisReplicationBaseUrl.copyFrom(value);
      return this;
    }

    public boolean hasRequiredFeatures() {
      return (bitField0_ & 0x00000040) != 0;
    }

    public HeaderBlock clearRequiredFeatures() {
      bitField0_ &= ~0x00000040;
      requiredFeatures.clear();
      return this;
    }

    /**
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableRequiredFeatures()} if you want to modify it.
     */
    public RepeatedString getRequiredFeatures() {
      return requiredFeatures;
    }

    /**
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     */
    public RepeatedString getMutableRequiredFeatures() {
      bitField0_ |= 0x00000040;
      return requiredFeatures;
    }

    public HeaderBlock addRequiredFeatures(final CharSequence value) {
      bitField0_ |= 0x00000040;
      requiredFeatures.add(value);
      return this;
    }

    public HeaderBlock addAllRequiredFeatures(final CharSequence... values) {
      bitField0_ |= 0x00000040;
      requiredFeatures.addAll(values);
      return this;
    }

    public boolean hasOptionalFeatures() {
      return (bitField0_ & 0x00000080) != 0;
    }

    public HeaderBlock clearOptionalFeatures() {
      bitField0_ &= ~0x00000080;
      optionalFeatures.clear();
      return this;
    }

    /**
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableOptionalFeatures()} if you want to modify it.
     */
    public RepeatedString getOptionalFeatures() {
      return optionalFeatures;
    }

    /**
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     */
    public RepeatedString getMutableOptionalFeatures() {
      bitField0_ |= 0x00000080;
      return optionalFeatures;
    }

    public HeaderBlock addOptionalFeatures(final CharSequence value) {
      bitField0_ |= 0x00000080;
      optionalFeatures.add(value);
      return this;
    }

    public HeaderBlock addAllOptionalFeatures(final CharSequence... values) {
      bitField0_ |= 0x00000080;
      optionalFeatures.addAll(values);
      return this;
    }

    @Override
    public HeaderBlock copyFrom(final HeaderBlock other) {
      cachedSize = other.cachedSize;
      if ((bitField0_ | other.bitField0_) != 0) {
        bitField0_ = other.bitField0_;
        osmosisReplicationTimestamp = other.osmosisReplicationTimestamp;
        osmosisReplicationSequenceNumber = other.osmosisReplicationSequenceNumber;
        bbox.copyFrom(other.bbox);
        writingprogram.copyFrom(other.writingprogram);
        source.copyFrom(other.source);
        osmosisReplicationBaseUrl.copyFrom(other.osmosisReplicationBaseUrl);
        requiredFeatures.copyFrom(other.requiredFeatures);
        optionalFeatures.copyFrom(other.optionalFeatures);
      }
      return this;
    }

    @Override
    public HeaderBlock mergeFrom(final HeaderBlock other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      if (other.hasOsmosisReplicationTimestamp()) {
        setOsmosisReplicationTimestamp(other.osmosisReplicationTimestamp);
      }
      if (other.hasOsmosisReplicationSequenceNumber()) {
        setOsmosisReplicationSequenceNumber(other.osmosisReplicationSequenceNumber);
      }
      if (other.hasBbox()) {
        getMutableBbox().mergeFrom(other.bbox);
      }
      if (other.hasWritingprogram()) {
        getMutableWritingprogramBytes().copyFrom(other.writingprogram);
      }
      if (other.hasSource()) {
        getMutableSourceBytes().copyFrom(other.source);
      }
      if (other.hasOsmosisReplicationBaseUrl()) {
        getMutableOsmosisReplicationBaseUrlBytes().copyFrom(other.osmosisReplicationBaseUrl);
      }
      if (other.hasRequiredFeatures()) {
        getMutableRequiredFeatures().addAll(other.requiredFeatures);
      }
      if (other.hasOptionalFeatures()) {
        getMutableOptionalFeatures().addAll(other.optionalFeatures);
      }
      return this;
    }

    @Override
    public HeaderBlock clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      osmosisReplicationTimestamp = 0L;
      osmosisReplicationSequenceNumber = 0L;
      bbox.clear();
      writingprogram.clear();
      source.clear();
      osmosisReplicationBaseUrl.clear();
      requiredFeatures.clear();
      optionalFeatures.clear();
      return this;
    }

    @Override
    public HeaderBlock clearQuick() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      bbox.clearQuick();
      writingprogram.clear();
      source.clear();
      osmosisReplicationBaseUrl.clear();
      requiredFeatures.clear();
      optionalFeatures.clear();
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof HeaderBlock)) {
        return false;
      }
      HeaderBlock other = (HeaderBlock) o;
      return bitField0_ == other.bitField0_
        && (!hasOsmosisReplicationTimestamp() || osmosisReplicationTimestamp == other.osmosisReplicationTimestamp)
        && (!hasOsmosisReplicationSequenceNumber() || osmosisReplicationSequenceNumber == other.osmosisReplicationSequenceNumber)
        && (!hasBbox() || bbox.equals(other.bbox))
        && (!hasWritingprogram() || writingprogram.equals(other.writingprogram))
        && (!hasSource() || source.equals(other.source))
        && (!hasOsmosisReplicationBaseUrl() || osmosisReplicationBaseUrl.equals(other.osmosisReplicationBaseUrl))
        && (!hasRequiredFeatures() || requiredFeatures.equals(other.requiredFeatures))
        && (!hasOptionalFeatures() || optionalFeatures.equals(other.optionalFeatures));
    }

    @Override
    public void writeTo(final ProtoSink output) throws IOException {
      try {
        if ((bitField0_ & 0x00000001) != 0) {
          output.writeRawLittleEndian16((short) 640);
          output.writeInt64NoTag(osmosisReplicationTimestamp);
        }
        if ((bitField0_ & 0x00000002) != 0) {
          output.writeRawLittleEndian16((short) 648);
          output.writeInt64NoTag(osmosisReplicationSequenceNumber);
        }
        if ((bitField0_ & 0x00000004) != 0) {
          output.writeRawByte((byte) 10);
          output.writeMessageNoTag(bbox);
        }
        if ((bitField0_ & 0x00000008) != 0) {
          output.writeRawLittleEndian16((short) 386);
          output.writeStringNoTag(writingprogram);
        }
        if ((bitField0_ & 0x00000010) != 0) {
          output.writeRawLittleEndian16((short) 394);
          output.writeStringNoTag(source);
        }
        if ((bitField0_ & 0x00000020) != 0) {
          output.writeRawLittleEndian16((short) 658);
          output.writeStringNoTag(osmosisReplicationBaseUrl);
        }
        if ((bitField0_ & 0x00000040) != 0) {
          for (int i = 0; i < requiredFeatures.length(); i++) {
            output.writeRawByte((byte) 34);
            output.writeStringNoTag(requiredFeatures.get(i));
          }
        }
        if ((bitField0_ & 0x00000080) != 0) {
          for (int i = 0; i < optionalFeatures.length(); i++) {
            output.writeRawByte((byte) 42);
            output.writeStringNoTag(optionalFeatures.get(i));
          }
        }
      } catch (UninitializedMessageException nestedFail) {
        throw rethrowFromParent(nestedFail);
      }
    }

    @Override
    protected int computeSerializedSize() {
      try {
        int size = 0;
        if ((bitField0_ & 0x00000001) != 0) {
          size += 2 + ProtoSink.computeInt64SizeNoTag(osmosisReplicationTimestamp);
        }
        if ((bitField0_ & 0x00000002) != 0) {
          size += 2 + ProtoSink.computeInt64SizeNoTag(osmosisReplicationSequenceNumber);
        }
        if ((bitField0_ & 0x00000004) != 0) {
          size += 1 + ProtoSink.computeMessageSizeNoTag(bbox);
        }
        if ((bitField0_ & 0x00000008) != 0) {
          size += 2 + ProtoSink.computeStringSizeNoTag(writingprogram);
        }
        if ((bitField0_ & 0x00000010) != 0) {
          size += 2 + ProtoSink.computeStringSizeNoTag(source);
        }
        if ((bitField0_ & 0x00000020) != 0) {
          size += 2 + ProtoSink.computeStringSizeNoTag(osmosisReplicationBaseUrl);
        }
        if ((bitField0_ & 0x00000040) != 0) {
          size += (1 * requiredFeatures.length()) + ProtoSink.computeRepeatedStringSizeNoTag(requiredFeatures);
        }
        if ((bitField0_ & 0x00000080) != 0) {
          size += (1 * optionalFeatures.length()) + ProtoSink.computeRepeatedStringSizeNoTag(optionalFeatures);
        }
        return size;
      } catch (UninitializedMessageException nestedFail) {
        throw rethrowFromParent(nestedFail);
      }
    }

    @Override
    public HeaderBlock mergeFrom(final ProtoSource input) throws IOException {
      // Enabled Fall-Through Optimization (QuickBuffers)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 256: {
            osmosisReplicationTimestamp = input.readInt64();
            bitField0_ |= 0x00000001;
            tag = input.readTag();
            if (tag != 264) {
              break;
            }
          }
          case 264: {
            osmosisReplicationSequenceNumber = input.readInt64();
            bitField0_ |= 0x00000002;
            tag = input.readTag();
            if (tag != 10) {
              break;
            }
          }
          case 10: {
            input.readMessage(bbox);
            bitField0_ |= 0x00000004;
            tag = input.readTag();
            if (tag != 130) {
              break;
            }
          }
          case 130: {
            input.readString(writingprogram);
            bitField0_ |= 0x00000008;
            tag = input.readTag();
            if (tag != 138) {
              break;
            }
          }
          case 138: {
            input.readString(source);
            bitField0_ |= 0x00000010;
            tag = input.readTag();
            if (tag != 274) {
              break;
            }
          }
          case 274: {
            input.readString(osmosisReplicationBaseUrl);
            bitField0_ |= 0x00000020;
            tag = input.readTag();
            if (tag != 34) {
              break;
            }
          }
          case 34: {
            tag = input.readRepeatedString(requiredFeatures, tag);
            bitField0_ |= 0x00000040;
            if (tag != 42) {
              break;
            }
          }
          case 42: {
            tag = input.readRepeatedString(optionalFeatures, tag);
            bitField0_ |= 0x00000080;
            if (tag != 0) {
              break;
            }
          }
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
        }
      }
    }

    @Override
    public final boolean isInitialized() {
      if (hasBbox() && !bbox.isInitialized()) {
        return false;
      }
      return true;
    }

    @Override
    protected final void getMissingFields(String prefix, List<String> results) {
      if (hasBbox() && !bbox.isInitialized()) {
        getMissingFields(prefix, "bbox", bbox, results);
      }
    }

    @Override
    public void writeTo(final JsonSink output) throws IOException {
      try {
        output.beginObject();
        if ((bitField0_ & 0x00000001) != 0) {
          output.writeInt64(FieldNames.osmosisReplicationTimestamp, osmosisReplicationTimestamp);
        }
        if ((bitField0_ & 0x00000002) != 0) {
          output.writeInt64(FieldNames.osmosisReplicationSequenceNumber, osmosisReplicationSequenceNumber);
        }
        if ((bitField0_ & 0x00000004) != 0) {
          output.writeMessage(FieldNames.bbox, bbox);
        }
        if ((bitField0_ & 0x00000008) != 0) {
          output.writeString(FieldNames.writingprogram, writingprogram);
        }
        if ((bitField0_ & 0x00000010) != 0) {
          output.writeString(FieldNames.source, source);
        }
        if ((bitField0_ & 0x00000020) != 0) {
          output.writeString(FieldNames.osmosisReplicationBaseUrl, osmosisReplicationBaseUrl);
        }
        if ((bitField0_ & 0x00000040) != 0) {
          output.writeRepeatedString(FieldNames.requiredFeatures, requiredFeatures);
        }
        if ((bitField0_ & 0x00000080) != 0) {
          output.writeRepeatedString(FieldNames.optionalFeatures, optionalFeatures);
        }
        output.endObject();
      } catch (UninitializedMessageException nestedFail) {
        throw rethrowFromParent(nestedFail);
      }
    }

    @Override
    public HeaderBlock mergeFrom(final JsonSource input) throws IOException {
      if (!input.beginObject()) {
        return this;
      }
      while (!input.isAtEnd()) {
        switch (input.readFieldHash()) {
          case -640778783:
          case -1243629893: {
            if (input.isAtField(FieldNames.osmosisReplicationTimestamp)) {
              osmosisReplicationTimestamp = input.readInt64();
              bitField0_ |= 0x00000001;
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -714957697:
          case -2095819924: {
            if (input.isAtField(FieldNames.osmosisReplicationSequenceNumber)) {
              osmosisReplicationSequenceNumber = input.readInt64();
              bitField0_ |= 0x00000002;
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 3017257: {
            if (input.isAtField(FieldNames.bbox)) {
              input.readMessage(bbox);
              bitField0_ |= 0x00000004;
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 1956558376: {
            if (input.isAtField(FieldNames.writingprogram)) {
              input.readString(writingprogram);
              bitField0_ |= 0x00000008;
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -896505829: {
            if (input.isAtField(FieldNames.source)) {
              input.readString(source);
              bitField0_ |= 0x00000010;
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -1861839767:
          case -1901603652: {
            if (input.isAtField(FieldNames.osmosisReplicationBaseUrl)) {
              input.readString(osmosisReplicationBaseUrl);
              bitField0_ |= 0x00000020;
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 1329489148:
          case 775851229: {
            if (input.isAtField(FieldNames.requiredFeatures)) {
              input.readRepeatedString(requiredFeatures);
              bitField0_ |= 0x00000040;
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -1442827331:
          case 733386300: {
            if (input.isAtField(FieldNames.optionalFeatures)) {
              input.readRepeatedString(optionalFeatures);
              bitField0_ |= 0x00000080;
            } else {
              input.skipUnknownField();
            }
            break;
          }
          default: {
            input.skipUnknownField();
            break;
          }
        }
      }
      input.endObject();
      return this;
    }

    @Override
    public HeaderBlock clone() {
      return new HeaderBlock().copyFrom(this);
    }

    public boolean isEmpty() {
      return ((bitField0_) == 0);
    }

    public static HeaderBlock parseFrom(final byte[] data) throws InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new HeaderBlock(), data).checkInitialized();
    }

    public static HeaderBlock parseFrom(final ProtoSource input) throws IOException {
      return ProtoMessage.mergeFrom(new HeaderBlock(), input).checkInitialized();
    }

    public static HeaderBlock parseFrom(final JsonSource input) throws IOException {
      return ProtoMessage.mergeFrom(new HeaderBlock(), input).checkInitialized();
    }

    public static MessageFactory<HeaderBlock> getFactory() {
      return HeaderBlockFactory.INSTANCE;
    }

    private enum HeaderBlockFactory implements MessageFactory<HeaderBlock> {
      INSTANCE;

      @Override
      public HeaderBlock create() {
        return HeaderBlock.newInstance();
      }
    }

    /**
     * Contains name constants used for serializing JSON
     */
    static class FieldNames {
      static final FieldName osmosisReplicationTimestamp = FieldName.forField("osmosisReplicationTimestamp", "osmosis_replication_timestamp");

      static final FieldName osmosisReplicationSequenceNumber = FieldName.forField("osmosisReplicationSequenceNumber", "osmosis_replication_sequence_number");

      static final FieldName bbox = FieldName.forField("bbox");

      static final FieldName writingprogram = FieldName.forField("writingprogram");

      static final FieldName source = FieldName.forField("source");

      static final FieldName osmosisReplicationBaseUrl = FieldName.forField("osmosisReplicationBaseUrl", "osmosis_replication_base_url");

      static final FieldName requiredFeatures = FieldName.forField("requiredFeatures", "required_features");

      static final FieldName optionalFeatures = FieldName.forField("optionalFeatures", "optional_features");
    }
  }

  public static final class HeaderBBox extends ProtoMessage<HeaderBBox> implements Cloneable {
    private static final long serialVersionUID = 0L;

    /**
     * required sint64 left = 1;
     */
    private long left;

    /**
     * required sint64 right = 2;
     */
    private long right;

    /**
     * required sint64 top = 3;
     */
    private long top;

    /**
     * required sint64 bottom = 4;
     */
    private long bottom;

    private HeaderBBox() {
    }

    public static HeaderBBox newInstance() {
      return new HeaderBBox();
    }

    public boolean hasLeft() {
      return (bitField0_ & 0x00000001) != 0;
    }

    public HeaderBBox clearLeft() {
      bitField0_ &= ~0x00000001;
      left = 0L;
      return this;
    }

    public long getLeft() {
      return left;
    }

    public HeaderBBox setLeft(final long value) {
      bitField0_ |= 0x00000001;
      left = value;
      return this;
    }

    public boolean hasRight() {
      return (bitField0_ & 0x00000002) != 0;
    }

    public HeaderBBox clearRight() {
      bitField0_ &= ~0x00000002;
      right = 0L;
      return this;
    }

    public long getRight() {
      return right;
    }

    public HeaderBBox setRight(final long value) {
      bitField0_ |= 0x00000002;
      right = value;
      return this;
    }

    public boolean hasTop() {
      return (bitField0_ & 0x00000004) != 0;
    }

    public HeaderBBox clearTop() {
      bitField0_ &= ~0x00000004;
      top = 0L;
      return this;
    }

    public long getTop() {
      return top;
    }

    public HeaderBBox setTop(final long value) {
      bitField0_ |= 0x00000004;
      top = value;
      return this;
    }

    public boolean hasBottom() {
      return (bitField0_ & 0x00000008) != 0;
    }

    public HeaderBBox clearBottom() {
      bitField0_ &= ~0x00000008;
      bottom = 0L;
      return this;
    }

    public long getBottom() {
      return bottom;
    }

    public HeaderBBox setBottom(final long value) {
      bitField0_ |= 0x00000008;
      bottom = value;
      return this;
    }

    @Override
    public HeaderBBox copyFrom(final HeaderBBox other) {
      cachedSize = other.cachedSize;
      if ((bitField0_ | other.bitField0_) != 0) {
        bitField0_ = other.bitField0_;
        left = other.left;
        right = other.right;
        top = other.top;
        bottom = other.bottom;
      }
      return this;
    }

    @Override
    public HeaderBBox mergeFrom(final HeaderBBox other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      if (other.hasLeft()) {
        setLeft(other.left);
      }
      if (other.hasRight()) {
        setRight(other.right);
      }
      if (other.hasTop()) {
        setTop(other.top);
      }
      if (other.hasBottom()) {
        setBottom(other.bottom);
      }
      return this;
    }

    @Override
    public HeaderBBox clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      left = 0L;
      right = 0L;
      top = 0L;
      bottom = 0L;
      return this;
    }

    @Override
    public HeaderBBox clearQuick() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof HeaderBBox)) {
        return false;
      }
      HeaderBBox other = (HeaderBBox) o;
      return bitField0_ == other.bitField0_
        && (!hasLeft() || left == other.left)
        && (!hasRight() || right == other.right)
        && (!hasTop() || top == other.top)
        && (!hasBottom() || bottom == other.bottom);
    }

    @Override
    public void writeTo(final ProtoSink output) throws IOException {
      if ((((bitField0_ & 0x0000000f) != 0x0000000f))) {
        throw new UninitializedMessageException(this);
      }
      try {
        output.writeRawByte((byte) 8);
        output.writeSInt64NoTag(left);
        output.writeRawByte((byte) 16);
        output.writeSInt64NoTag(right);
        output.writeRawByte((byte) 24);
        output.writeSInt64NoTag(top);
        output.writeRawByte((byte) 32);
        output.writeSInt64NoTag(bottom);
      } catch (UninitializedMessageException nestedFail) {
        throw rethrowFromParent(nestedFail);
      }
    }

    @Override
    protected int computeSerializedSize() {
      if ((((bitField0_ & 0x0000000f) != 0x0000000f))) {
        throw new UninitializedMessageException(this);
      }
      try {
        int size = 0;
        size += 1 + ProtoSink.computeSInt64SizeNoTag(left);
        size += 1 + ProtoSink.computeSInt64SizeNoTag(right);
        size += 1 + ProtoSink.computeSInt64SizeNoTag(top);
        size += 1 + ProtoSink.computeSInt64SizeNoTag(bottom);
        return size;
      } catch (UninitializedMessageException nestedFail) {
        throw rethrowFromParent(nestedFail);
      }
    }

    @Override
    public HeaderBBox mergeFrom(final ProtoSource input) throws IOException {
      // Enabled Fall-Through Optimization (QuickBuffers)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 8: {
            left = input.readSInt64();
            bitField0_ |= 0x00000001;
            tag = input.readTag();
            if (tag != 16) {
              break;
            }
          }
          case 16: {
            right = input.readSInt64();
            bitField0_ |= 0x00000002;
            tag = input.readTag();
            if (tag != 24) {
              break;
            }
          }
          case 24: {
            top = input.readSInt64();
            bitField0_ |= 0x00000004;
            tag = input.readTag();
            if (tag != 32) {
              break;
            }
          }
          case 32: {
            bottom = input.readSInt64();
            bitField0_ |= 0x00000008;
            tag = input.readTag();
            if (tag != 0) {
              break;
            }
          }
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
        }
      }
    }

    @Override
    public final boolean isInitialized() {
      if ((((bitField0_ & 0x0000000f) != 0x0000000f))) {
        return false;
      }
      return true;
    }

    @Override
    protected final void getMissingFields(String prefix, List<String> results) {
      if (!hasLeft()) {
        results.add(prefix + "left");
      }
      if (!hasRight()) {
        results.add(prefix + "right");
      }
      if (!hasTop()) {
        results.add(prefix + "top");
      }
      if (!hasBottom()) {
        results.add(prefix + "bottom");
      }
    }

    @Override
    public void writeTo(final JsonSink output) throws IOException {
      if ((((bitField0_ & 0x0000000f) != 0x0000000f))) {
        throw new UninitializedMessageException(this);
      }
      try {
        output.beginObject();
        output.writeSInt64(FieldNames.left, left);
        output.writeSInt64(FieldNames.right, right);
        output.writeSInt64(FieldNames.top, top);
        output.writeSInt64(FieldNames.bottom, bottom);
        output.endObject();
      } catch (UninitializedMessageException nestedFail) {
        throw rethrowFromParent(nestedFail);
      }
    }

    @Override
    public HeaderBBox mergeFrom(final JsonSource input) throws IOException {
      if (!input.beginObject()) {
        return this;
      }
      while (!input.isAtEnd()) {
        switch (input.readFieldHash()) {
          case 3317767: {
            if (input.isAtField(FieldNames.left)) {
              left = input.readSInt64();
              bitField0_ |= 0x00000001;
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 108511772: {
            if (input.isAtField(FieldNames.right)) {
              right = input.readSInt64();
              bitField0_ |= 0x00000002;
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 115029: {
            if (input.isAtField(FieldNames.top)) {
              top = input.readSInt64();
              bitField0_ |= 0x00000004;
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -1383228885: {
            if (input.isAtField(FieldNames.bottom)) {
              bottom = input.readSInt64();
              bitField0_ |= 0x00000008;
            } else {
              input.skipUnknownField();
            }
            break;
          }
          default: {
            input.skipUnknownField();
            break;
          }
        }
      }
      input.endObject();
      return this;
    }

    @Override
    public HeaderBBox clone() {
      return new HeaderBBox().copyFrom(this);
    }

    public boolean isEmpty() {
      return ((bitField0_) == 0);
    }

    public static HeaderBBox parseFrom(final byte[] data) throws InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new HeaderBBox(), data).checkInitialized();
    }

    public static HeaderBBox parseFrom(final ProtoSource input) throws IOException {
      return ProtoMessage.mergeFrom(new HeaderBBox(), input).checkInitialized();
    }

    public static HeaderBBox parseFrom(final JsonSource input) throws IOException {
      return ProtoMessage.mergeFrom(new HeaderBBox(), input).checkInitialized();
    }

    public static MessageFactory<HeaderBBox> getFactory() {
      return HeaderBBoxFactory.INSTANCE;
    }

    private enum HeaderBBoxFactory implements MessageFactory<HeaderBBox> {
      INSTANCE;

      @Override
      public HeaderBBox create() {
        return HeaderBBox.newInstance();
      }
    }

    /**
     * Contains name constants used for serializing JSON
     */
    static class FieldNames {
      static final FieldName left = FieldName.forField("left");

      static final FieldName right = FieldName.forField("right");

      static final FieldName top = FieldName.forField("top");

      static final FieldName bottom = FieldName.forField("bottom");
    }
  }

  public static final class PrimitiveBlock extends ProtoMessage<PrimitiveBlock> implements Cloneable {
    private static final long serialVersionUID = 0L;

    /**
     * optional int64 lat_offset = 19 [default = 0];
     */
    private long latOffset = 0L;

    /**
     * optional int64 lon_offset = 20 [default = 0];
     */
    private long lonOffset = 0L;

    /**
     * optional int32 granularity = 17 [default = 100];
     */
    private int granularity = 100;

    /**
     * optional int32 date_granularity = 18 [default = 1000];
     */
    private int dateGranularity = 1000;

    /**
     * required .OSMPBF.StringTable stringtable = 1;
     */
    private final StringTable stringtable = StringTable.newInstance();

    /**
     * repeated .OSMPBF.PrimitiveGroup primitivegroup = 2;
     */
    private final RepeatedMessage<PrimitiveGroup> primitivegroup = RepeatedMessage.newEmptyInstance(PrimitiveGroup.getFactory());

    private PrimitiveBlock() {
    }

    public static PrimitiveBlock newInstance() {
      return new PrimitiveBlock();
    }

    public boolean hasLatOffset() {
      return (bitField0_ & 0x00000002) != 0;
    }

    public PrimitiveBlock clearLatOffset() {
      bitField0_ &= ~0x00000002;
      latOffset = 0L;
      return this;
    }

    public long getLatOffset() {
      return latOffset;
    }

    public PrimitiveBlock setLatOffset(final long value) {
      bitField0_ |= 0x00000002;
      latOffset = value;
      return this;
    }

    public boolean hasLonOffset() {
      return (bitField0_ & 0x00000004) != 0;
    }

    public PrimitiveBlock clearLonOffset() {
      bitField0_ &= ~0x00000004;
      lonOffset = 0L;
      return this;
    }

    public long getLonOffset() {
      return lonOffset;
    }

    public PrimitiveBlock setLonOffset(final long value) {
      bitField0_ |= 0x00000004;
      lonOffset = value;
      return this;
    }

    public boolean hasGranularity() {
      return (bitField0_ & 0x00000008) != 0;
    }

    public PrimitiveBlock clearGranularity() {
      bitField0_ &= ~0x00000008;
      granularity = 100;
      return this;
    }

    public int getGranularity() {
      return granularity;
    }

    public PrimitiveBlock setGranularity(final int value) {
      bitField0_ |= 0x00000008;
      granularity = value;
      return this;
    }

    public boolean hasDateGranularity() {
      return (bitField0_ & 0x00000010) != 0;
    }

    public PrimitiveBlock clearDateGranularity() {
      bitField0_ &= ~0x00000010;
      dateGranularity = 1000;
      return this;
    }

    public int getDateGranularity() {
      return dateGranularity;
    }

    public PrimitiveBlock setDateGranularity(final int value) {
      bitField0_ |= 0x00000010;
      dateGranularity = value;
      return this;
    }

    public boolean hasStringtable() {
      return (bitField0_ & 0x00000001) != 0;
    }

    public PrimitiveBlock clearStringtable() {
      bitField0_ &= ~0x00000001;
      stringtable.clear();
      return this;
    }

    /**
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableStringtable()} if you want to modify it.
     */
    public StringTable getStringtable() {
      return stringtable;
    }

    /**
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     */
    public StringTable getMutableStringtable() {
      bitField0_ |= 0x00000001;
      return stringtable;
    }

    public PrimitiveBlock setStringtable(final StringTable value) {
      bitField0_ |= 0x00000001;
      stringtable.copyFrom(value);
      return this;
    }

    public boolean hasPrimitivegroup() {
      return (bitField0_ & 0x00000020) != 0;
    }

    public PrimitiveBlock clearPrimitivegroup() {
      bitField0_ &= ~0x00000020;
      primitivegroup.clear();
      return this;
    }

    /**
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutablePrimitivegroup()} if you want to modify it.
     */
    public RepeatedMessage<PrimitiveGroup> getPrimitivegroup() {
      return primitivegroup;
    }

    /**
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     */
    public RepeatedMessage<PrimitiveGroup> getMutablePrimitivegroup() {
      bitField0_ |= 0x00000020;
      return primitivegroup;
    }

    public PrimitiveBlock addPrimitivegroup(final PrimitiveGroup value) {
      bitField0_ |= 0x00000020;
      primitivegroup.add(value);
      return this;
    }

    public PrimitiveBlock addAllPrimitivegroup(final PrimitiveGroup... values) {
      bitField0_ |= 0x00000020;
      primitivegroup.addAll(values);
      return this;
    }

    @Override
    public PrimitiveBlock copyFrom(final PrimitiveBlock other) {
      cachedSize = other.cachedSize;
      if ((bitField0_ | other.bitField0_) != 0) {
        bitField0_ = other.bitField0_;
        latOffset = other.latOffset;
        lonOffset = other.lonOffset;
        granularity = other.granularity;
        dateGranularity = other.dateGranularity;
        stringtable.copyFrom(other.stringtable);
        primitivegroup.copyFrom(other.primitivegroup);
      }
      return this;
    }

    @Override
    public PrimitiveBlock mergeFrom(final PrimitiveBlock other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      if (other.hasLatOffset()) {
        setLatOffset(other.latOffset);
      }
      if (other.hasLonOffset()) {
        setLonOffset(other.lonOffset);
      }
      if (other.hasGranularity()) {
        setGranularity(other.granularity);
      }
      if (other.hasDateGranularity()) {
        setDateGranularity(other.dateGranularity);
      }
      if (other.hasStringtable()) {
        getMutableStringtable().mergeFrom(other.stringtable);
      }
      if (other.hasPrimitivegroup()) {
        getMutablePrimitivegroup().addAll(other.primitivegroup);
      }
      return this;
    }

    @Override
    public PrimitiveBlock clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      latOffset = 0L;
      lonOffset = 0L;
      granularity = 100;
      dateGranularity = 1000;
      stringtable.clear();
      primitivegroup.clear();
      return this;
    }

    @Override
    public PrimitiveBlock clearQuick() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      stringtable.clearQuick();
      primitivegroup.clearQuick();
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof PrimitiveBlock)) {
        return false;
      }
      PrimitiveBlock other = (PrimitiveBlock) o;
      return bitField0_ == other.bitField0_
        && (!hasLatOffset() || latOffset == other.latOffset)
        && (!hasLonOffset() || lonOffset == other.lonOffset)
        && (!hasGranularity() || granularity == other.granularity)
        && (!hasDateGranularity() || dateGranularity == other.dateGranularity)
        && (!hasStringtable() || stringtable.equals(other.stringtable))
        && (!hasPrimitivegroup() || primitivegroup.equals(other.primitivegroup));
    }

    @Override
    public void writeTo(final ProtoSink output) throws IOException {
      if ((((bitField0_ & 0x00000001) != 0x00000001))) {
        throw new UninitializedMessageException(this);
      }
      try {
        if ((bitField0_ & 0x00000002) != 0) {
          output.writeRawLittleEndian16((short) 408);
          output.writeInt64NoTag(latOffset);
        }
        if ((bitField0_ & 0x00000004) != 0) {
          output.writeRawLittleEndian16((short) 416);
          output.writeInt64NoTag(lonOffset);
        }
        if ((bitField0_ & 0x00000008) != 0) {
          output.writeRawLittleEndian16((short) 392);
          output.writeInt32NoTag(granularity);
        }
        if ((bitField0_ & 0x00000010) != 0) {
          output.writeRawLittleEndian16((short) 400);
          output.writeInt32NoTag(dateGranularity);
        }
        output.writeRawByte((byte) 10);
        output.writeMessageNoTag(stringtable);
        if ((bitField0_ & 0x00000020) != 0) {
          for (int i = 0; i < primitivegroup.length(); i++) {
            output.writeRawByte((byte) 18);
            output.writeMessageNoTag(primitivegroup.get(i));
          }
        }
      } catch (UninitializedMessageException nestedFail) {
        throw rethrowFromParent(nestedFail);
      }
    }

    @Override
    protected int computeSerializedSize() {
      if ((((bitField0_ & 0x00000001) != 0x00000001))) {
        throw new UninitializedMessageException(this);
      }
      try {
        int size = 0;
        if ((bitField0_ & 0x00000002) != 0) {
          size += 2 + ProtoSink.computeInt64SizeNoTag(latOffset);
        }
        if ((bitField0_ & 0x00000004) != 0) {
          size += 2 + ProtoSink.computeInt64SizeNoTag(lonOffset);
        }
        if ((bitField0_ & 0x00000008) != 0) {
          size += 2 + ProtoSink.computeInt32SizeNoTag(granularity);
        }
        if ((bitField0_ & 0x00000010) != 0) {
          size += 2 + ProtoSink.computeInt32SizeNoTag(dateGranularity);
        }
        size += 1 + ProtoSink.computeMessageSizeNoTag(stringtable);
        if ((bitField0_ & 0x00000020) != 0) {
          size += (1 * primitivegroup.length()) + ProtoSink.computeRepeatedMessageSizeNoTag(primitivegroup);
        }
        return size;
      } catch (UninitializedMessageException nestedFail) {
        throw rethrowFromParent(nestedFail);
      }
    }

    @Override
    public PrimitiveBlock mergeFrom(final ProtoSource input) throws IOException {
      // Enabled Fall-Through Optimization (QuickBuffers)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 152: {
            latOffset = input.readInt64();
            bitField0_ |= 0x00000002;
            tag = input.readTag();
            if (tag != 160) {
              break;
            }
          }
          case 160: {
            lonOffset = input.readInt64();
            bitField0_ |= 0x00000004;
            tag = input.readTag();
            if (tag != 136) {
              break;
            }
          }
          case 136: {
            granularity = input.readInt32();
            bitField0_ |= 0x00000008;
            tag = input.readTag();
            if (tag != 144) {
              break;
            }
          }
          case 144: {
            dateGranularity = input.readInt32();
            bitField0_ |= 0x00000010;
            tag = input.readTag();
            if (tag != 10) {
              break;
            }
          }
          case 10: {
            input.readMessage(stringtable);
            bitField0_ |= 0x00000001;
            tag = input.readTag();
            if (tag != 18) {
              break;
            }
          }
          case 18: {
            tag = input.readRepeatedMessage(primitivegroup, tag);
            bitField0_ |= 0x00000020;
            if (tag != 0) {
              break;
            }
          }
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
        }
      }
    }

    @Override
    public final boolean isInitialized() {
      if ((((bitField0_ & 0x00000001) != 0x00000001))) {
        return false;
      }
      if (hasPrimitivegroup() && !primitivegroup.isInitialized()) {
        return false;
      }
      return true;
    }

    @Override
    protected final void getMissingFields(String prefix, List<String> results) {
      if (!hasStringtable()) {
        results.add(prefix + "stringtable");
      }
      if (hasPrimitivegroup() && !primitivegroup.isInitialized()) {
        getMissingFields(prefix, "primitivegroup", primitivegroup, results);
      }
    }

    @Override
    public void writeTo(final JsonSink output) throws IOException {
      if ((((bitField0_ & 0x00000001) != 0x00000001))) {
        throw new UninitializedMessageException(this);
      }
      try {
        output.beginObject();
        if ((bitField0_ & 0x00000002) != 0) {
          output.writeInt64(FieldNames.latOffset, latOffset);
        }
        if ((bitField0_ & 0x00000004) != 0) {
          output.writeInt64(FieldNames.lonOffset, lonOffset);
        }
        if ((bitField0_ & 0x00000008) != 0) {
          output.writeInt32(FieldNames.granularity, granularity);
        }
        if ((bitField0_ & 0x00000010) != 0) {
          output.writeInt32(FieldNames.dateGranularity, dateGranularity);
        }
        output.writeMessage(FieldNames.stringtable, stringtable);
        if ((bitField0_ & 0x00000020) != 0) {
          output.writeRepeatedMessage(FieldNames.primitivegroup, primitivegroup);
        }
        output.endObject();
      } catch (UninitializedMessageException nestedFail) {
        throw rethrowFromParent(nestedFail);
      }
    }

    @Override
    public PrimitiveBlock mergeFrom(final JsonSource input) throws IOException {
      if (!input.beginObject()) {
        return this;
      }
      while (!input.isAtEnd()) {
        switch (input.readFieldHash()) {
          case 1847590674:
          case -1281786061: {
            if (input.isAtField(FieldNames.latOffset)) {
              latOffset = input.readInt64();
              bitField0_ |= 0x00000002;
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -552923202:
          case 1611695111: {
            if (input.isAtField(FieldNames.lonOffset)) {
              lonOffset = input.readInt64();
              bitField0_ |= 0x00000004;
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 1819831630: {
            if (input.isAtField(FieldNames.granularity)) {
              granularity = input.readInt32();
              bitField0_ |= 0x00000008;
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -1693045568:
          case -491542979: {
            if (input.isAtField(FieldNames.dateGranularity)) {
              dateGranularity = input.readInt32();
              bitField0_ |= 0x00000010;
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -1491517859: {
            if (input.isAtField(FieldNames.stringtable)) {
              input.readMessage(stringtable);
              bitField0_ |= 0x00000001;
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -1519066632: {
            if (input.isAtField(FieldNames.primitivegroup)) {
              input.readRepeatedMessage(primitivegroup);
              bitField0_ |= 0x00000020;
            } else {
              input.skipUnknownField();
            }
            break;
          }
          default: {
            input.skipUnknownField();
            break;
          }
        }
      }
      input.endObject();
      return this;
    }

    @Override
    public PrimitiveBlock clone() {
      return new PrimitiveBlock().copyFrom(this);
    }

    public boolean isEmpty() {
      return ((bitField0_) == 0);
    }

    public static PrimitiveBlock parseFrom(final byte[] data) throws
        InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new PrimitiveBlock(), data).checkInitialized();
    }

    public static PrimitiveBlock parseFrom(final ProtoSource input) throws IOException {
      return ProtoMessage.mergeFrom(new PrimitiveBlock(), input).checkInitialized();
    }

    public static PrimitiveBlock parseFrom(final JsonSource input) throws IOException {
      return ProtoMessage.mergeFrom(new PrimitiveBlock(), input).checkInitialized();
    }

    public static MessageFactory<PrimitiveBlock> getFactory() {
      return PrimitiveBlockFactory.INSTANCE;
    }

    private enum PrimitiveBlockFactory implements MessageFactory<PrimitiveBlock> {
      INSTANCE;

      @Override
      public PrimitiveBlock create() {
        return PrimitiveBlock.newInstance();
      }
    }

    /**
     * Contains name constants used for serializing JSON
     */
    static class FieldNames {
      static final FieldName latOffset = FieldName.forField("latOffset", "lat_offset");

      static final FieldName lonOffset = FieldName.forField("lonOffset", "lon_offset");

      static final FieldName granularity = FieldName.forField("granularity");

      static final FieldName dateGranularity = FieldName.forField("dateGranularity", "date_granularity");

      static final FieldName stringtable = FieldName.forField("stringtable");

      static final FieldName primitivegroup = FieldName.forField("primitivegroup");
    }
  }

  public static final class PrimitiveGroup extends ProtoMessage<PrimitiveGroup> implements Cloneable {
    private static final long serialVersionUID = 0L;

    /**
     * optional .OSMPBF.DenseNodes dense = 2;
     */
    private final DenseNodes dense = DenseNodes.newInstance();

    /**
     * repeated .OSMPBF.Node nodes = 1;
     */
    private final RepeatedMessage<Node> nodes = RepeatedMessage.newEmptyInstance(Node.getFactory());

    /**
     * repeated .OSMPBF.Way ways = 3;
     */
    private final RepeatedMessage<Way> ways = RepeatedMessage.newEmptyInstance(Way.getFactory());

    /**
     * repeated .OSMPBF.Relation relations = 4;
     */
    private final RepeatedMessage<Relation> relations = RepeatedMessage.newEmptyInstance(Relation.getFactory());

    /**
     * repeated .OSMPBF.ChangeSet changesets = 5;
     */
    private final RepeatedMessage<ChangeSet> changesets = RepeatedMessage.newEmptyInstance(ChangeSet.getFactory());

    private PrimitiveGroup() {
    }

    public static PrimitiveGroup newInstance() {
      return new PrimitiveGroup();
    }

    public boolean hasDense() {
      return (bitField0_ & 0x00000001) != 0;
    }

    public PrimitiveGroup clearDense() {
      bitField0_ &= ~0x00000001;
      dense.clear();
      return this;
    }

    /**
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableDense()} if you want to modify it.
     */
    public DenseNodes getDense() {
      return dense;
    }

    /**
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     */
    public DenseNodes getMutableDense() {
      bitField0_ |= 0x00000001;
      return dense;
    }

    public PrimitiveGroup setDense(final DenseNodes value) {
      bitField0_ |= 0x00000001;
      dense.copyFrom(value);
      return this;
    }

    public boolean hasNodes() {
      return (bitField0_ & 0x00000002) != 0;
    }

    public PrimitiveGroup clearNodes() {
      bitField0_ &= ~0x00000002;
      nodes.clear();
      return this;
    }

    /**
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableNodes()} if you want to modify it.
     */
    public RepeatedMessage<Node> getNodes() {
      return nodes;
    }

    /**
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     */
    public RepeatedMessage<Node> getMutableNodes() {
      bitField0_ |= 0x00000002;
      return nodes;
    }

    public PrimitiveGroup addNodes(final Node value) {
      bitField0_ |= 0x00000002;
      nodes.add(value);
      return this;
    }

    public PrimitiveGroup addAllNodes(final Node... values) {
      bitField0_ |= 0x00000002;
      nodes.addAll(values);
      return this;
    }

    public boolean hasWays() {
      return (bitField0_ & 0x00000004) != 0;
    }

    public PrimitiveGroup clearWays() {
      bitField0_ &= ~0x00000004;
      ways.clear();
      return this;
    }

    /**
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableWays()} if you want to modify it.
     */
    public RepeatedMessage<Way> getWays() {
      return ways;
    }

    /**
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     */
    public RepeatedMessage<Way> getMutableWays() {
      bitField0_ |= 0x00000004;
      return ways;
    }

    public PrimitiveGroup addWays(final Way value) {
      bitField0_ |= 0x00000004;
      ways.add(value);
      return this;
    }

    public PrimitiveGroup addAllWays(final Way... values) {
      bitField0_ |= 0x00000004;
      ways.addAll(values);
      return this;
    }

    public boolean hasRelations() {
      return (bitField0_ & 0x00000008) != 0;
    }

    public PrimitiveGroup clearRelations() {
      bitField0_ &= ~0x00000008;
      relations.clear();
      return this;
    }

    /**
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableRelations()} if you want to modify it.
     */
    public RepeatedMessage<Relation> getRelations() {
      return relations;
    }

    /**
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     */
    public RepeatedMessage<Relation> getMutableRelations() {
      bitField0_ |= 0x00000008;
      return relations;
    }

    public PrimitiveGroup addRelations(final Relation value) {
      bitField0_ |= 0x00000008;
      relations.add(value);
      return this;
    }

    public PrimitiveGroup addAllRelations(final Relation... values) {
      bitField0_ |= 0x00000008;
      relations.addAll(values);
      return this;
    }

    public boolean hasChangesets() {
      return (bitField0_ & 0x00000010) != 0;
    }

    public PrimitiveGroup clearChangesets() {
      bitField0_ &= ~0x00000010;
      changesets.clear();
      return this;
    }

    /**
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableChangesets()} if you want to modify it.
     */
    public RepeatedMessage<ChangeSet> getChangesets() {
      return changesets;
    }

    /**
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     */
    public RepeatedMessage<ChangeSet> getMutableChangesets() {
      bitField0_ |= 0x00000010;
      return changesets;
    }

    public PrimitiveGroup addChangesets(final ChangeSet value) {
      bitField0_ |= 0x00000010;
      changesets.add(value);
      return this;
    }

    public PrimitiveGroup addAllChangesets(final ChangeSet... values) {
      bitField0_ |= 0x00000010;
      changesets.addAll(values);
      return this;
    }

    @Override
    public PrimitiveGroup copyFrom(final PrimitiveGroup other) {
      cachedSize = other.cachedSize;
      if ((bitField0_ | other.bitField0_) != 0) {
        bitField0_ = other.bitField0_;
        dense.copyFrom(other.dense);
        nodes.copyFrom(other.nodes);
        ways.copyFrom(other.ways);
        relations.copyFrom(other.relations);
        changesets.copyFrom(other.changesets);
      }
      return this;
    }

    @Override
    public PrimitiveGroup mergeFrom(final PrimitiveGroup other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      if (other.hasDense()) {
        getMutableDense().mergeFrom(other.dense);
      }
      if (other.hasNodes()) {
        getMutableNodes().addAll(other.nodes);
      }
      if (other.hasWays()) {
        getMutableWays().addAll(other.ways);
      }
      if (other.hasRelations()) {
        getMutableRelations().addAll(other.relations);
      }
      if (other.hasChangesets()) {
        getMutableChangesets().addAll(other.changesets);
      }
      return this;
    }

    @Override
    public PrimitiveGroup clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      dense.clear();
      nodes.clear();
      ways.clear();
      relations.clear();
      changesets.clear();
      return this;
    }

    @Override
    public PrimitiveGroup clearQuick() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      dense.clearQuick();
      nodes.clearQuick();
      ways.clearQuick();
      relations.clearQuick();
      changesets.clearQuick();
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof PrimitiveGroup)) {
        return false;
      }
      PrimitiveGroup other = (PrimitiveGroup) o;
      return bitField0_ == other.bitField0_
        && (!hasDense() || dense.equals(other.dense))
        && (!hasNodes() || nodes.equals(other.nodes))
        && (!hasWays() || ways.equals(other.ways))
        && (!hasRelations() || relations.equals(other.relations))
        && (!hasChangesets() || changesets.equals(other.changesets));
    }

    @Override
    public void writeTo(final ProtoSink output) throws IOException {
      try {
        if ((bitField0_ & 0x00000001) != 0) {
          output.writeRawByte((byte) 18);
          output.writeMessageNoTag(dense);
        }
        if ((bitField0_ & 0x00000002) != 0) {
          for (int i = 0; i < nodes.length(); i++) {
            output.writeRawByte((byte) 10);
            output.writeMessageNoTag(nodes.get(i));
          }
        }
        if ((bitField0_ & 0x00000004) != 0) {
          for (int i = 0; i < ways.length(); i++) {
            output.writeRawByte((byte) 26);
            output.writeMessageNoTag(ways.get(i));
          }
        }
        if ((bitField0_ & 0x00000008) != 0) {
          for (int i = 0; i < relations.length(); i++) {
            output.writeRawByte((byte) 34);
            output.writeMessageNoTag(relations.get(i));
          }
        }
        if ((bitField0_ & 0x00000010) != 0) {
          for (int i = 0; i < changesets.length(); i++) {
            output.writeRawByte((byte) 42);
            output.writeMessageNoTag(changesets.get(i));
          }
        }
      } catch (UninitializedMessageException nestedFail) {
        throw rethrowFromParent(nestedFail);
      }
    }

    @Override
    protected int computeSerializedSize() {
      try {
        int size = 0;
        if ((bitField0_ & 0x00000001) != 0) {
          size += 1 + ProtoSink.computeMessageSizeNoTag(dense);
        }
        if ((bitField0_ & 0x00000002) != 0) {
          size += (1 * nodes.length()) + ProtoSink.computeRepeatedMessageSizeNoTag(nodes);
        }
        if ((bitField0_ & 0x00000004) != 0) {
          size += (1 * ways.length()) + ProtoSink.computeRepeatedMessageSizeNoTag(ways);
        }
        if ((bitField0_ & 0x00000008) != 0) {
          size += (1 * relations.length()) + ProtoSink.computeRepeatedMessageSizeNoTag(relations);
        }
        if ((bitField0_ & 0x00000010) != 0) {
          size += (1 * changesets.length()) + ProtoSink.computeRepeatedMessageSizeNoTag(changesets);
        }
        return size;
      } catch (UninitializedMessageException nestedFail) {
        throw rethrowFromParent(nestedFail);
      }
    }

    @Override
    public PrimitiveGroup mergeFrom(final ProtoSource input) throws IOException {
      // Enabled Fall-Through Optimization (QuickBuffers)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 18: {
            input.readMessage(dense);
            bitField0_ |= 0x00000001;
            tag = input.readTag();
            if (tag != 10) {
              break;
            }
          }
          case 10: {
            tag = input.readRepeatedMessage(nodes, tag);
            bitField0_ |= 0x00000002;
            if (tag != 26) {
              break;
            }
          }
          case 26: {
            tag = input.readRepeatedMessage(ways, tag);
            bitField0_ |= 0x00000004;
            if (tag != 34) {
              break;
            }
          }
          case 34: {
            tag = input.readRepeatedMessage(relations, tag);
            bitField0_ |= 0x00000008;
            if (tag != 42) {
              break;
            }
          }
          case 42: {
            tag = input.readRepeatedMessage(changesets, tag);
            bitField0_ |= 0x00000010;
            if (tag != 0) {
              break;
            }
          }
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
        }
      }
    }

    @Override
    public final boolean isInitialized() {
      if (hasNodes() && !nodes.isInitialized()) {
        return false;
      }
      if (hasWays() && !ways.isInitialized()) {
        return false;
      }
      if (hasRelations() && !relations.isInitialized()) {
        return false;
      }
      if (hasChangesets() && !changesets.isInitialized()) {
        return false;
      }
      return true;
    }

    @Override
    protected final void getMissingFields(String prefix, List<String> results) {
      if (hasNodes() && !nodes.isInitialized()) {
        getMissingFields(prefix, "nodes", nodes, results);
      }
      if (hasWays() && !ways.isInitialized()) {
        getMissingFields(prefix, "ways", ways, results);
      }
      if (hasRelations() && !relations.isInitialized()) {
        getMissingFields(prefix, "relations", relations, results);
      }
      if (hasChangesets() && !changesets.isInitialized()) {
        getMissingFields(prefix, "changesets", changesets, results);
      }
    }

    @Override
    public void writeTo(final JsonSink output) throws IOException {
      try {
        output.beginObject();
        if ((bitField0_ & 0x00000001) != 0) {
          output.writeMessage(FieldNames.dense, dense);
        }
        if ((bitField0_ & 0x00000002) != 0) {
          output.writeRepeatedMessage(FieldNames.nodes, nodes);
        }
        if ((bitField0_ & 0x00000004) != 0) {
          output.writeRepeatedMessage(FieldNames.ways, ways);
        }
        if ((bitField0_ & 0x00000008) != 0) {
          output.writeRepeatedMessage(FieldNames.relations, relations);
        }
        if ((bitField0_ & 0x00000010) != 0) {
          output.writeRepeatedMessage(FieldNames.changesets, changesets);
        }
        output.endObject();
      } catch (UninitializedMessageException nestedFail) {
        throw rethrowFromParent(nestedFail);
      }
    }

    @Override
    public PrimitiveGroup mergeFrom(final JsonSource input) throws IOException {
      if (!input.beginObject()) {
        return this;
      }
      while (!input.isAtEnd()) {
        switch (input.readFieldHash()) {
          case 95470367: {
            if (input.isAtField(FieldNames.dense)) {
              input.readMessage(dense);
              bitField0_ |= 0x00000001;
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 104993457: {
            if (input.isAtField(FieldNames.nodes)) {
              input.readRepeatedMessage(nodes);
              bitField0_ |= 0x00000002;
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 3642212: {
            if (input.isAtField(FieldNames.ways)) {
              input.readRepeatedMessage(ways);
              bitField0_ |= 0x00000004;
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -7649801: {
            if (input.isAtField(FieldNames.relations)) {
              input.readRepeatedMessage(relations);
              bitField0_ |= 0x00000008;
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -2130998271: {
            if (input.isAtField(FieldNames.changesets)) {
              input.readRepeatedMessage(changesets);
              bitField0_ |= 0x00000010;
            } else {
              input.skipUnknownField();
            }
            break;
          }
          default: {
            input.skipUnknownField();
            break;
          }
        }
      }
      input.endObject();
      return this;
    }

    @Override
    public PrimitiveGroup clone() {
      return new PrimitiveGroup().copyFrom(this);
    }

    public boolean isEmpty() {
      return ((bitField0_) == 0);
    }

    public static PrimitiveGroup parseFrom(final byte[] data) throws
        InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new PrimitiveGroup(), data).checkInitialized();
    }

    public static PrimitiveGroup parseFrom(final ProtoSource input) throws IOException {
      return ProtoMessage.mergeFrom(new PrimitiveGroup(), input).checkInitialized();
    }

    public static PrimitiveGroup parseFrom(final JsonSource input) throws IOException {
      return ProtoMessage.mergeFrom(new PrimitiveGroup(), input).checkInitialized();
    }

    public static MessageFactory<PrimitiveGroup> getFactory() {
      return PrimitiveGroupFactory.INSTANCE;
    }

    private enum PrimitiveGroupFactory implements MessageFactory<PrimitiveGroup> {
      INSTANCE;

      @Override
      public PrimitiveGroup create() {
        return PrimitiveGroup.newInstance();
      }
    }

    /**
     * Contains name constants used for serializing JSON
     */
    static class FieldNames {
      static final FieldName dense = FieldName.forField("dense");

      static final FieldName nodes = FieldName.forField("nodes");

      static final FieldName ways = FieldName.forField("ways");

      static final FieldName relations = FieldName.forField("relations");

      static final FieldName changesets = FieldName.forField("changesets");
    }
  }

  public static final class StringTable extends ProtoMessage<StringTable> implements Cloneable {
    private static final long serialVersionUID = 0L;

    /**
     * repeated bytes s = 1;
     */
    private final RepeatedBytes s = RepeatedBytes.newEmptyInstance();

    private StringTable() {
    }

    public static StringTable newInstance() {
      return new StringTable();
    }

    public boolean hasS() {
      return (bitField0_ & 0x00000001) != 0;
    }

    public StringTable clearS() {
      bitField0_ &= ~0x00000001;
      s.clear();
      return this;
    }

    /**
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableS()} if you want to modify it.
     */
    public RepeatedBytes getS() {
      return s;
    }

    /**
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     */
    public RepeatedBytes getMutableS() {
      bitField0_ |= 0x00000001;
      return s;
    }

    public StringTable addS(final byte[] value) {
      bitField0_ |= 0x00000001;
      s.add(value);
      return this;
    }

    public StringTable addAllS(final byte[]... values) {
      bitField0_ |= 0x00000001;
      s.addAll(values);
      return this;
    }

    @Override
    public StringTable copyFrom(final StringTable other) {
      cachedSize = other.cachedSize;
      if ((bitField0_ | other.bitField0_) != 0) {
        bitField0_ = other.bitField0_;
        s.copyFrom(other.s);
      }
      return this;
    }

    @Override
    public StringTable mergeFrom(final StringTable other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      if (other.hasS()) {
        getMutableS().addAll(other.s);
      }
      return this;
    }

    @Override
    public StringTable clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      s.clear();
      return this;
    }

    @Override
    public StringTable clearQuick() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      s.clear();
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof StringTable)) {
        return false;
      }
      StringTable other = (StringTable) o;
      return bitField0_ == other.bitField0_
        && (!hasS() || s.equals(other.s));
    }

    @Override
    public void writeTo(final ProtoSink output) throws IOException {
      if ((bitField0_ & 0x00000001) != 0) {
        for (int i = 0; i < s.length(); i++) {
          output.writeRawByte((byte) 10);
          output.writeBytesNoTag(s.get(i));
        }
      }
    }

    @Override
    protected int computeSerializedSize() {
      int size = 0;
      if ((bitField0_ & 0x00000001) != 0) {
        size += (1 * s.length()) + ProtoSink.computeRepeatedBytesSizeNoTag(s);
      }
      return size;
    }

    @Override
    public StringTable mergeFrom(final ProtoSource input) throws IOException {
      // Enabled Fall-Through Optimization (QuickBuffers)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 10: {
            tag = input.readRepeatedBytes(s, tag);
            bitField0_ |= 0x00000001;
            if (tag != 0) {
              break;
            }
          }
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
        }
      }
    }

    @Override
    public void writeTo(final JsonSink output) throws IOException {
      output.beginObject();
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeRepeatedBytes(FieldNames.s, s);
      }
      output.endObject();
    }

    @Override
    public StringTable mergeFrom(final JsonSource input) throws IOException {
      if (!input.beginObject()) {
        return this;
      }
      while (!input.isAtEnd()) {
        switch (input.readFieldHash()) {
          case 115: {
            if (input.isAtField(FieldNames.s)) {
              input.readRepeatedBytes(s);
              bitField0_ |= 0x00000001;
            } else {
              input.skipUnknownField();
            }
            break;
          }
          default: {
            input.skipUnknownField();
            break;
          }
        }
      }
      input.endObject();
      return this;
    }

    @Override
    public StringTable clone() {
      return new StringTable().copyFrom(this);
    }

    public boolean isEmpty() {
      return ((bitField0_) == 0);
    }

    public static StringTable parseFrom(final byte[] data) throws InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new StringTable(), data).checkInitialized();
    }

    public static StringTable parseFrom(final ProtoSource input) throws IOException {
      return ProtoMessage.mergeFrom(new StringTable(), input).checkInitialized();
    }

    public static StringTable parseFrom(final JsonSource input) throws IOException {
      return ProtoMessage.mergeFrom(new StringTable(), input).checkInitialized();
    }

    public static MessageFactory<StringTable> getFactory() {
      return StringTableFactory.INSTANCE;
    }

    private enum StringTableFactory implements MessageFactory<StringTable> {
      INSTANCE;

      @Override
      public StringTable create() {
        return StringTable.newInstance();
      }
    }

    /**
     * Contains name constants used for serializing JSON
     */
    static class FieldNames {
      static final FieldName s = FieldName.forField("s");
    }
  }

  public static final class Info extends ProtoMessage<Info> implements Cloneable {
    private static final long serialVersionUID = 0L;

    /**
     * optional int64 timestamp = 2;
     */
    private long timestamp;

    /**
     * optional int64 changeset = 3;
     */
    private long changeset;

    /**
     * optional int32 version = 1 [default = -1];
     */
    private int version = -1;

    /**
     * optional int32 uid = 4;
     */
    private int uid;

    /**
     * optional uint32 user_sid = 5;
     */
    private int userSid;

    /**
     * optional bool visible = 6;
     */
    private boolean visible;

    private Info() {
    }

    public static Info newInstance() {
      return new Info();
    }

    public boolean hasTimestamp() {
      return (bitField0_ & 0x00000001) != 0;
    }

    public Info clearTimestamp() {
      bitField0_ &= ~0x00000001;
      timestamp = 0L;
      return this;
    }

    public long getTimestamp() {
      return timestamp;
    }

    public Info setTimestamp(final long value) {
      bitField0_ |= 0x00000001;
      timestamp = value;
      return this;
    }

    public boolean hasChangeset() {
      return (bitField0_ & 0x00000002) != 0;
    }

    public Info clearChangeset() {
      bitField0_ &= ~0x00000002;
      changeset = 0L;
      return this;
    }

    public long getChangeset() {
      return changeset;
    }

    public Info setChangeset(final long value) {
      bitField0_ |= 0x00000002;
      changeset = value;
      return this;
    }

    public boolean hasVersion() {
      return (bitField0_ & 0x00000004) != 0;
    }

    public Info clearVersion() {
      bitField0_ &= ~0x00000004;
      version = -1;
      return this;
    }

    public int getVersion() {
      return version;
    }

    public Info setVersion(final int value) {
      bitField0_ |= 0x00000004;
      version = value;
      return this;
    }

    public boolean hasUid() {
      return (bitField0_ & 0x00000008) != 0;
    }

    public Info clearUid() {
      bitField0_ &= ~0x00000008;
      uid = 0;
      return this;
    }

    public int getUid() {
      return uid;
    }

    public Info setUid(final int value) {
      bitField0_ |= 0x00000008;
      uid = value;
      return this;
    }

    public boolean hasUserSid() {
      return (bitField0_ & 0x00000010) != 0;
    }

    public Info clearUserSid() {
      bitField0_ &= ~0x00000010;
      userSid = 0;
      return this;
    }

    public int getUserSid() {
      return userSid;
    }

    public Info setUserSid(final int value) {
      bitField0_ |= 0x00000010;
      userSid = value;
      return this;
    }

    public boolean hasVisible() {
      return (bitField0_ & 0x00000020) != 0;
    }

    public Info clearVisible() {
      bitField0_ &= ~0x00000020;
      visible = false;
      return this;
    }

    public boolean getVisible() {
      return visible;
    }

    public Info setVisible(final boolean value) {
      bitField0_ |= 0x00000020;
      visible = value;
      return this;
    }

    @Override
    public Info copyFrom(final Info other) {
      cachedSize = other.cachedSize;
      if ((bitField0_ | other.bitField0_) != 0) {
        bitField0_ = other.bitField0_;
        timestamp = other.timestamp;
        changeset = other.changeset;
        version = other.version;
        uid = other.uid;
        userSid = other.userSid;
        visible = other.visible;
      }
      return this;
    }

    @Override
    public Info mergeFrom(final Info other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      if (other.hasTimestamp()) {
        setTimestamp(other.timestamp);
      }
      if (other.hasChangeset()) {
        setChangeset(other.changeset);
      }
      if (other.hasVersion()) {
        setVersion(other.version);
      }
      if (other.hasUid()) {
        setUid(other.uid);
      }
      if (other.hasUserSid()) {
        setUserSid(other.userSid);
      }
      if (other.hasVisible()) {
        setVisible(other.visible);
      }
      return this;
    }

    @Override
    public Info clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      timestamp = 0L;
      changeset = 0L;
      version = -1;
      uid = 0;
      userSid = 0;
      visible = false;
      return this;
    }

    @Override
    public Info clearQuick() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof Info)) {
        return false;
      }
      Info other = (Info) o;
      return bitField0_ == other.bitField0_
        && (!hasTimestamp() || timestamp == other.timestamp)
        && (!hasChangeset() || changeset == other.changeset)
        && (!hasVersion() || version == other.version)
        && (!hasUid() || uid == other.uid)
        && (!hasUserSid() || userSid == other.userSid)
        && (!hasVisible() || visible == other.visible);
    }

    @Override
    public void writeTo(final ProtoSink output) throws IOException {
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeRawByte((byte) 16);
        output.writeInt64NoTag(timestamp);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeRawByte((byte) 24);
        output.writeInt64NoTag(changeset);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeRawByte((byte) 8);
        output.writeInt32NoTag(version);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        output.writeRawByte((byte) 32);
        output.writeInt32NoTag(uid);
      }
      if ((bitField0_ & 0x00000010) != 0) {
        output.writeRawByte((byte) 40);
        output.writeUInt32NoTag(userSid);
      }
      if ((bitField0_ & 0x00000020) != 0) {
        output.writeRawByte((byte) 48);
        output.writeBoolNoTag(visible);
      }
    }

    @Override
    protected int computeSerializedSize() {
      int size = 0;
      if ((bitField0_ & 0x00000001) != 0) {
        size += 1 + ProtoSink.computeInt64SizeNoTag(timestamp);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        size += 1 + ProtoSink.computeInt64SizeNoTag(changeset);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        size += 1 + ProtoSink.computeInt32SizeNoTag(version);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        size += 1 + ProtoSink.computeInt32SizeNoTag(uid);
      }
      if ((bitField0_ & 0x00000010) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(userSid);
      }
      if ((bitField0_ & 0x00000020) != 0) {
        size += 2;
      }
      return size;
    }

    @Override
    public Info mergeFrom(final ProtoSource input) throws IOException {
      // Enabled Fall-Through Optimization (QuickBuffers)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 16: {
            timestamp = input.readInt64();
            bitField0_ |= 0x00000001;
            tag = input.readTag();
            if (tag != 24) {
              break;
            }
          }
          case 24: {
            changeset = input.readInt64();
            bitField0_ |= 0x00000002;
            tag = input.readTag();
            if (tag != 8) {
              break;
            }
          }
          case 8: {
            version = input.readInt32();
            bitField0_ |= 0x00000004;
            tag = input.readTag();
            if (tag != 32) {
              break;
            }
          }
          case 32: {
            uid = input.readInt32();
            bitField0_ |= 0x00000008;
            tag = input.readTag();
            if (tag != 40) {
              break;
            }
          }
          case 40: {
            userSid = input.readUInt32();
            bitField0_ |= 0x00000010;
            tag = input.readTag();
            if (tag != 48) {
              break;
            }
          }
          case 48: {
            visible = input.readBool();
            bitField0_ |= 0x00000020;
            tag = input.readTag();
            if (tag != 0) {
              break;
            }
          }
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
        }
      }
    }

    @Override
    public void writeTo(final JsonSink output) throws IOException {
      output.beginObject();
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeInt64(FieldNames.timestamp, timestamp);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeInt64(FieldNames.changeset, changeset);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeInt32(FieldNames.version, version);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        output.writeInt32(FieldNames.uid, uid);
      }
      if ((bitField0_ & 0x00000010) != 0) {
        output.writeUInt32(FieldNames.userSid, userSid);
      }
      if ((bitField0_ & 0x00000020) != 0) {
        output.writeBool(FieldNames.visible, visible);
      }
      output.endObject();
    }

    @Override
    public Info mergeFrom(final JsonSource input) throws IOException {
      if (!input.beginObject()) {
        return this;
      }
      while (!input.isAtEnd()) {
        switch (input.readFieldHash()) {
          case 55126294: {
            if (input.isAtField(FieldNames.timestamp)) {
              timestamp = input.readInt64();
              bitField0_ |= 0x00000001;
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 1455278770: {
            if (input.isAtField(FieldNames.changeset)) {
              changeset = input.readInt64();
              bitField0_ |= 0x00000002;
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 351608024: {
            if (input.isAtField(FieldNames.version)) {
              version = input.readInt32();
              bitField0_ |= 0x00000004;
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 115792: {
            if (input.isAtField(FieldNames.uid)) {
              uid = input.readInt32();
              bitField0_ |= 0x00000008;
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -147144445:
          case -266143142: {
            if (input.isAtField(FieldNames.userSid)) {
              userSid = input.readUInt32();
              bitField0_ |= 0x00000010;
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 466743410: {
            if (input.isAtField(FieldNames.visible)) {
              visible = input.readBool();
              bitField0_ |= 0x00000020;
            } else {
              input.skipUnknownField();
            }
            break;
          }
          default: {
            input.skipUnknownField();
            break;
          }
        }
      }
      input.endObject();
      return this;
    }

    @Override
    public Info clone() {
      return new Info().copyFrom(this);
    }

    public boolean isEmpty() {
      return ((bitField0_) == 0);
    }

    public static Info parseFrom(final byte[] data) throws InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new Info(), data).checkInitialized();
    }

    public static Info parseFrom(final ProtoSource input) throws IOException {
      return ProtoMessage.mergeFrom(new Info(), input).checkInitialized();
    }

    public static Info parseFrom(final JsonSource input) throws IOException {
      return ProtoMessage.mergeFrom(new Info(), input).checkInitialized();
    }

    public static MessageFactory<Info> getFactory() {
      return InfoFactory.INSTANCE;
    }

    private enum InfoFactory implements MessageFactory<Info> {
      INSTANCE;

      @Override
      public Info create() {
        return Info.newInstance();
      }
    }

    /**
     * Contains name constants used for serializing JSON
     */
    static class FieldNames {
      static final FieldName timestamp = FieldName.forField("timestamp");

      static final FieldName changeset = FieldName.forField("changeset");

      static final FieldName version = FieldName.forField("version");

      static final FieldName uid = FieldName.forField("uid");

      static final FieldName userSid = FieldName.forField("userSid", "user_sid");

      static final FieldName visible = FieldName.forField("visible");
    }
  }

  public static final class DenseInfo extends ProtoMessage<DenseInfo> implements Cloneable {
    private static final long serialVersionUID = 0L;

    /**
     * repeated sint64 timestamp = 2 [packed = true];
     */
    private final RepeatedLong timestamp = RepeatedLong.newEmptyInstance();

    /**
     * repeated sint64 changeset = 3 [packed = true];
     */
    private final RepeatedLong changeset = RepeatedLong.newEmptyInstance();

    /**
     * repeated int32 version = 1 [packed = true];
     */
    private final RepeatedInt version = RepeatedInt.newEmptyInstance();

    /**
     * repeated sint32 uid = 4 [packed = true];
     */
    private final RepeatedInt uid = RepeatedInt.newEmptyInstance();

    /**
     * repeated sint32 user_sid = 5 [packed = true];
     */
    private final RepeatedInt userSid = RepeatedInt.newEmptyInstance();

    /**
     * repeated bool visible = 6 [packed = true];
     */
    private final RepeatedBoolean visible = RepeatedBoolean.newEmptyInstance();

    private DenseInfo() {
    }

    public static DenseInfo newInstance() {
      return new DenseInfo();
    }

    public boolean hasTimestamp() {
      return (bitField0_ & 0x00000001) != 0;
    }

    public DenseInfo clearTimestamp() {
      bitField0_ &= ~0x00000001;
      timestamp.clear();
      return this;
    }

    /**
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableTimestamp()} if you want to modify it.
     */
    public RepeatedLong getTimestamp() {
      return timestamp;
    }

    /**
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     */
    public RepeatedLong getMutableTimestamp() {
      bitField0_ |= 0x00000001;
      return timestamp;
    }

    public DenseInfo addTimestamp(final long value) {
      bitField0_ |= 0x00000001;
      timestamp.add(value);
      return this;
    }

    public DenseInfo addAllTimestamp(final long... values) {
      bitField0_ |= 0x00000001;
      timestamp.addAll(values);
      return this;
    }

    public boolean hasChangeset() {
      return (bitField0_ & 0x00000002) != 0;
    }

    public DenseInfo clearChangeset() {
      bitField0_ &= ~0x00000002;
      changeset.clear();
      return this;
    }

    /**
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableChangeset()} if you want to modify it.
     */
    public RepeatedLong getChangeset() {
      return changeset;
    }

    /**
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     */
    public RepeatedLong getMutableChangeset() {
      bitField0_ |= 0x00000002;
      return changeset;
    }

    public DenseInfo addChangeset(final long value) {
      bitField0_ |= 0x00000002;
      changeset.add(value);
      return this;
    }

    public DenseInfo addAllChangeset(final long... values) {
      bitField0_ |= 0x00000002;
      changeset.addAll(values);
      return this;
    }

    public boolean hasVersion() {
      return (bitField0_ & 0x00000004) != 0;
    }

    public DenseInfo clearVersion() {
      bitField0_ &= ~0x00000004;
      version.clear();
      return this;
    }

    /**
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableVersion()} if you want to modify it.
     */
    public RepeatedInt getVersion() {
      return version;
    }

    /**
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     */
    public RepeatedInt getMutableVersion() {
      bitField0_ |= 0x00000004;
      return version;
    }

    public DenseInfo addVersion(final int value) {
      bitField0_ |= 0x00000004;
      version.add(value);
      return this;
    }

    public DenseInfo addAllVersion(final int... values) {
      bitField0_ |= 0x00000004;
      version.addAll(values);
      return this;
    }

    public boolean hasUid() {
      return (bitField0_ & 0x00000008) != 0;
    }

    public DenseInfo clearUid() {
      bitField0_ &= ~0x00000008;
      uid.clear();
      return this;
    }

    /**
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableUid()} if you want to modify it.
     */
    public RepeatedInt getUid() {
      return uid;
    }

    /**
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     */
    public RepeatedInt getMutableUid() {
      bitField0_ |= 0x00000008;
      return uid;
    }

    public DenseInfo addUid(final int value) {
      bitField0_ |= 0x00000008;
      uid.add(value);
      return this;
    }

    public DenseInfo addAllUid(final int... values) {
      bitField0_ |= 0x00000008;
      uid.addAll(values);
      return this;
    }

    public boolean hasUserSid() {
      return (bitField0_ & 0x00000010) != 0;
    }

    public DenseInfo clearUserSid() {
      bitField0_ &= ~0x00000010;
      userSid.clear();
      return this;
    }

    /**
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableUserSid()} if you want to modify it.
     */
    public RepeatedInt getUserSid() {
      return userSid;
    }

    /**
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     */
    public RepeatedInt getMutableUserSid() {
      bitField0_ |= 0x00000010;
      return userSid;
    }

    public DenseInfo addUserSid(final int value) {
      bitField0_ |= 0x00000010;
      userSid.add(value);
      return this;
    }

    public DenseInfo addAllUserSid(final int... values) {
      bitField0_ |= 0x00000010;
      userSid.addAll(values);
      return this;
    }

    public boolean hasVisible() {
      return (bitField0_ & 0x00000020) != 0;
    }

    public DenseInfo clearVisible() {
      bitField0_ &= ~0x00000020;
      visible.clear();
      return this;
    }

    /**
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableVisible()} if you want to modify it.
     */
    public RepeatedBoolean getVisible() {
      return visible;
    }

    /**
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     */
    public RepeatedBoolean getMutableVisible() {
      bitField0_ |= 0x00000020;
      return visible;
    }

    public DenseInfo addVisible(final boolean value) {
      bitField0_ |= 0x00000020;
      visible.add(value);
      return this;
    }

    public DenseInfo addAllVisible(final boolean... values) {
      bitField0_ |= 0x00000020;
      visible.addAll(values);
      return this;
    }

    @Override
    public DenseInfo copyFrom(final DenseInfo other) {
      cachedSize = other.cachedSize;
      if ((bitField0_ | other.bitField0_) != 0) {
        bitField0_ = other.bitField0_;
        timestamp.copyFrom(other.timestamp);
        changeset.copyFrom(other.changeset);
        version.copyFrom(other.version);
        uid.copyFrom(other.uid);
        userSid.copyFrom(other.userSid);
        visible.copyFrom(other.visible);
      }
      return this;
    }

    @Override
    public DenseInfo mergeFrom(final DenseInfo other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      if (other.hasTimestamp()) {
        getMutableTimestamp().addAll(other.timestamp);
      }
      if (other.hasChangeset()) {
        getMutableChangeset().addAll(other.changeset);
      }
      if (other.hasVersion()) {
        getMutableVersion().addAll(other.version);
      }
      if (other.hasUid()) {
        getMutableUid().addAll(other.uid);
      }
      if (other.hasUserSid()) {
        getMutableUserSid().addAll(other.userSid);
      }
      if (other.hasVisible()) {
        getMutableVisible().addAll(other.visible);
      }
      return this;
    }

    @Override
    public DenseInfo clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      timestamp.clear();
      changeset.clear();
      version.clear();
      uid.clear();
      userSid.clear();
      visible.clear();
      return this;
    }

    @Override
    public DenseInfo clearQuick() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      timestamp.clear();
      changeset.clear();
      version.clear();
      uid.clear();
      userSid.clear();
      visible.clear();
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof DenseInfo)) {
        return false;
      }
      DenseInfo other = (DenseInfo) o;
      return bitField0_ == other.bitField0_
        && (!hasTimestamp() || timestamp.equals(other.timestamp))
        && (!hasChangeset() || changeset.equals(other.changeset))
        && (!hasVersion() || version.equals(other.version))
        && (!hasUid() || uid.equals(other.uid))
        && (!hasUserSid() || userSid.equals(other.userSid))
        && (!hasVisible() || visible.equals(other.visible));
    }

    @Override
    public void writeTo(final ProtoSink output) throws IOException {
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeRawByte((byte) 18);
        output.writePackedSInt64NoTag(timestamp);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeRawByte((byte) 26);
        output.writePackedSInt64NoTag(changeset);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeRawByte((byte) 10);
        output.writePackedInt32NoTag(version);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        output.writeRawByte((byte) 34);
        output.writePackedSInt32NoTag(uid);
      }
      if ((bitField0_ & 0x00000010) != 0) {
        output.writeRawByte((byte) 42);
        output.writePackedSInt32NoTag(userSid);
      }
      if ((bitField0_ & 0x00000020) != 0) {
        output.writeRawByte((byte) 50);
        output.writePackedBoolNoTag(visible);
      }
    }

    @Override
    protected int computeSerializedSize() {
      int size = 0;
      if ((bitField0_ & 0x00000001) != 0) {
        final int dataSize = ProtoSink.computeRepeatedSInt64SizeNoTag(timestamp);
        size += 1 + ProtoSink.computeDelimitedSize(dataSize);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        final int dataSize = ProtoSink.computeRepeatedSInt64SizeNoTag(changeset);
        size += 1 + ProtoSink.computeDelimitedSize(dataSize);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        final int dataSize = ProtoSink.computeRepeatedInt32SizeNoTag(version);
        size += 1 + ProtoSink.computeDelimitedSize(dataSize);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        final int dataSize = ProtoSink.computeRepeatedSInt32SizeNoTag(uid);
        size += 1 + ProtoSink.computeDelimitedSize(dataSize);
      }
      if ((bitField0_ & 0x00000010) != 0) {
        final int dataSize = ProtoSink.computeRepeatedSInt32SizeNoTag(userSid);
        size += 1 + ProtoSink.computeDelimitedSize(dataSize);
      }
      if ((bitField0_ & 0x00000020) != 0) {
        final int dataSize = 1 * visible.length();
        size += 1 + ProtoSink.computeDelimitedSize(dataSize);
      }
      return size;
    }

    @Override
    public DenseInfo mergeFrom(final ProtoSource input) throws IOException {
      // Enabled Fall-Through Optimization (QuickBuffers)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 18: {
            input.readPackedSInt64(timestamp, tag);
            bitField0_ |= 0x00000001;
            tag = input.readTag();
            if (tag != 26) {
              break;
            }
          }
          case 26: {
            input.readPackedSInt64(changeset, tag);
            bitField0_ |= 0x00000002;
            tag = input.readTag();
            if (tag != 10) {
              break;
            }
          }
          case 10: {
            input.readPackedInt32(version, tag);
            bitField0_ |= 0x00000004;
            tag = input.readTag();
            if (tag != 34) {
              break;
            }
          }
          case 34: {
            input.readPackedSInt32(uid, tag);
            bitField0_ |= 0x00000008;
            tag = input.readTag();
            if (tag != 42) {
              break;
            }
          }
          case 42: {
            input.readPackedSInt32(userSid, tag);
            bitField0_ |= 0x00000010;
            tag = input.readTag();
            if (tag != 50) {
              break;
            }
          }
          case 50: {
            input.readPackedBool(visible);
            bitField0_ |= 0x00000020;
            tag = input.readTag();
            if (tag != 0) {
              break;
            }
          }
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
          case 16: {
            tag = input.readRepeatedSInt64(timestamp, tag);
            bitField0_ |= 0x00000001;
            break;
          }
          case 24: {
            tag = input.readRepeatedSInt64(changeset, tag);
            bitField0_ |= 0x00000002;
            break;
          }
          case 8: {
            tag = input.readRepeatedInt32(version, tag);
            bitField0_ |= 0x00000004;
            break;
          }
          case 32: {
            tag = input.readRepeatedSInt32(uid, tag);
            bitField0_ |= 0x00000008;
            break;
          }
          case 40: {
            tag = input.readRepeatedSInt32(userSid, tag);
            bitField0_ |= 0x00000010;
            break;
          }
          case 48: {
            tag = input.readRepeatedBool(visible, tag);
            bitField0_ |= 0x00000020;
            break;
          }
        }
      }
    }

    @Override
    public void writeTo(final JsonSink output) throws IOException {
      output.beginObject();
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeRepeatedSInt64(FieldNames.timestamp, timestamp);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeRepeatedSInt64(FieldNames.changeset, changeset);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeRepeatedInt32(FieldNames.version, version);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        output.writeRepeatedSInt32(FieldNames.uid, uid);
      }
      if ((bitField0_ & 0x00000010) != 0) {
        output.writeRepeatedSInt32(FieldNames.userSid, userSid);
      }
      if ((bitField0_ & 0x00000020) != 0) {
        output.writeRepeatedBool(FieldNames.visible, visible);
      }
      output.endObject();
    }

    @Override
    public DenseInfo mergeFrom(final JsonSource input) throws IOException {
      if (!input.beginObject()) {
        return this;
      }
      while (!input.isAtEnd()) {
        switch (input.readFieldHash()) {
          case 55126294: {
            if (input.isAtField(FieldNames.timestamp)) {
              input.readRepeatedSInt64(timestamp);
              bitField0_ |= 0x00000001;
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 1455278770: {
            if (input.isAtField(FieldNames.changeset)) {
              input.readRepeatedSInt64(changeset);
              bitField0_ |= 0x00000002;
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 351608024: {
            if (input.isAtField(FieldNames.version)) {
              input.readRepeatedInt32(version);
              bitField0_ |= 0x00000004;
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 115792: {
            if (input.isAtField(FieldNames.uid)) {
              input.readRepeatedSInt32(uid);
              bitField0_ |= 0x00000008;
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -147144445:
          case -266143142: {
            if (input.isAtField(FieldNames.userSid)) {
              input.readRepeatedSInt32(userSid);
              bitField0_ |= 0x00000010;
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 466743410: {
            if (input.isAtField(FieldNames.visible)) {
              input.readRepeatedBool(visible);
              bitField0_ |= 0x00000020;
            } else {
              input.skipUnknownField();
            }
            break;
          }
          default: {
            input.skipUnknownField();
            break;
          }
        }
      }
      input.endObject();
      return this;
    }

    @Override
    public DenseInfo clone() {
      return new DenseInfo().copyFrom(this);
    }

    public boolean isEmpty() {
      return ((bitField0_) == 0);
    }

    public static DenseInfo parseFrom(final byte[] data) throws InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new DenseInfo(), data).checkInitialized();
    }

    public static DenseInfo parseFrom(final ProtoSource input) throws IOException {
      return ProtoMessage.mergeFrom(new DenseInfo(), input).checkInitialized();
    }

    public static DenseInfo parseFrom(final JsonSource input) throws IOException {
      return ProtoMessage.mergeFrom(new DenseInfo(), input).checkInitialized();
    }

    public static MessageFactory<DenseInfo> getFactory() {
      return DenseInfoFactory.INSTANCE;
    }

    private enum DenseInfoFactory implements MessageFactory<DenseInfo> {
      INSTANCE;

      @Override
      public DenseInfo create() {
        return DenseInfo.newInstance();
      }
    }

    /**
     * Contains name constants used for serializing JSON
     */
    static class FieldNames {
      static final FieldName timestamp = FieldName.forField("timestamp");

      static final FieldName changeset = FieldName.forField("changeset");

      static final FieldName version = FieldName.forField("version");

      static final FieldName uid = FieldName.forField("uid");

      static final FieldName userSid = FieldName.forField("userSid", "user_sid");

      static final FieldName visible = FieldName.forField("visible");
    }
  }

  public static final class ChangeSet extends ProtoMessage<ChangeSet> implements Cloneable {
    private static final long serialVersionUID = 0L;

    /**
     * required int64 id = 1;
     */
    private long id;

    private ChangeSet() {
    }

    public static ChangeSet newInstance() {
      return new ChangeSet();
    }

    public boolean hasId() {
      return (bitField0_ & 0x00000001) != 0;
    }

    public ChangeSet clearId() {
      bitField0_ &= ~0x00000001;
      id = 0L;
      return this;
    }

    public long getId() {
      return id;
    }

    public ChangeSet setId(final long value) {
      bitField0_ |= 0x00000001;
      id = value;
      return this;
    }

    @Override
    public ChangeSet copyFrom(final ChangeSet other) {
      cachedSize = other.cachedSize;
      if ((bitField0_ | other.bitField0_) != 0) {
        bitField0_ = other.bitField0_;
        id = other.id;
      }
      return this;
    }

    @Override
    public ChangeSet mergeFrom(final ChangeSet other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      if (other.hasId()) {
        setId(other.id);
      }
      return this;
    }

    @Override
    public ChangeSet clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      id = 0L;
      return this;
    }

    @Override
    public ChangeSet clearQuick() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof ChangeSet)) {
        return false;
      }
      ChangeSet other = (ChangeSet) o;
      return bitField0_ == other.bitField0_
        && (!hasId() || id == other.id);
    }

    @Override
    public void writeTo(final ProtoSink output) throws IOException {
      if ((((bitField0_ & 0x00000001) != 0x00000001))) {
        throw new UninitializedMessageException(this);
      }
      try {
        output.writeRawByte((byte) 8);
        output.writeInt64NoTag(id);
      } catch (UninitializedMessageException nestedFail) {
        throw rethrowFromParent(nestedFail);
      }
    }

    @Override
    protected int computeSerializedSize() {
      if ((((bitField0_ & 0x00000001) != 0x00000001))) {
        throw new UninitializedMessageException(this);
      }
      try {
        int size = 0;
        size += 1 + ProtoSink.computeInt64SizeNoTag(id);
        return size;
      } catch (UninitializedMessageException nestedFail) {
        throw rethrowFromParent(nestedFail);
      }
    }

    @Override
    public ChangeSet mergeFrom(final ProtoSource input) throws IOException {
      // Enabled Fall-Through Optimization (QuickBuffers)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 8: {
            id = input.readInt64();
            bitField0_ |= 0x00000001;
            tag = input.readTag();
            if (tag != 0) {
              break;
            }
          }
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
        }
      }
    }

    @Override
    public final boolean isInitialized() {
      if ((((bitField0_ & 0x00000001) != 0x00000001))) {
        return false;
      }
      return true;
    }

    @Override
    protected final void getMissingFields(String prefix, List<String> results) {
      if (!hasId()) {
        results.add(prefix + "id");
      }
    }

    @Override
    public void writeTo(final JsonSink output) throws IOException {
      if ((((bitField0_ & 0x00000001) != 0x00000001))) {
        throw new UninitializedMessageException(this);
      }
      try {
        output.beginObject();
        output.writeInt64(FieldNames.id, id);
        output.endObject();
      } catch (UninitializedMessageException nestedFail) {
        throw rethrowFromParent(nestedFail);
      }
    }

    @Override
    public ChangeSet mergeFrom(final JsonSource input) throws IOException {
      if (!input.beginObject()) {
        return this;
      }
      while (!input.isAtEnd()) {
        switch (input.readFieldHash()) {
          case 3355: {
            if (input.isAtField(FieldNames.id)) {
              id = input.readInt64();
              bitField0_ |= 0x00000001;
            } else {
              input.skipUnknownField();
            }
            break;
          }
          default: {
            input.skipUnknownField();
            break;
          }
        }
      }
      input.endObject();
      return this;
    }

    @Override
    public ChangeSet clone() {
      return new ChangeSet().copyFrom(this);
    }

    public boolean isEmpty() {
      return ((bitField0_) == 0);
    }

    public static ChangeSet parseFrom(final byte[] data) throws InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new ChangeSet(), data).checkInitialized();
    }

    public static ChangeSet parseFrom(final ProtoSource input) throws IOException {
      return ProtoMessage.mergeFrom(new ChangeSet(), input).checkInitialized();
    }

    public static ChangeSet parseFrom(final JsonSource input) throws IOException {
      return ProtoMessage.mergeFrom(new ChangeSet(), input).checkInitialized();
    }

    public static MessageFactory<ChangeSet> getFactory() {
      return ChangeSetFactory.INSTANCE;
    }

    private enum ChangeSetFactory implements MessageFactory<ChangeSet> {
      INSTANCE;

      @Override
      public ChangeSet create() {
        return ChangeSet.newInstance();
      }
    }

    /**
     * Contains name constants used for serializing JSON
     */
    static class FieldNames {
      static final FieldName id = FieldName.forField("id");
    }
  }

  public static final class Node extends ProtoMessage<Node> implements Cloneable {
    private static final long serialVersionUID = 0L;

    /**
     * required sint64 id = 1;
     */
    private long id;

    /**
     * required sint64 lat = 8;
     */
    private long lat;

    /**
     * required sint64 lon = 9;
     */
    private long lon;

    /**
     * optional .OSMPBF.Info info = 4;
     */
    private final Info info = Info.newInstance();

    /**
     * repeated uint32 keys = 2 [packed = true];
     */
    private final RepeatedInt keys = RepeatedInt.newEmptyInstance();

    /**
     * repeated uint32 vals = 3 [packed = true];
     */
    private final RepeatedInt vals = RepeatedInt.newEmptyInstance();

    private Node() {
    }

    public static Node newInstance() {
      return new Node();
    }

    public boolean hasId() {
      return (bitField0_ & 0x00000008) != 0;
    }

    public Node clearId() {
      bitField0_ &= ~0x00000008;
      id = 0L;
      return this;
    }

    public long getId() {
      return id;
    }

    public Node setId(final long value) {
      bitField0_ |= 0x00000008;
      id = value;
      return this;
    }

    public boolean hasLat() {
      return (bitField0_ & 0x00000010) != 0;
    }

    public Node clearLat() {
      bitField0_ &= ~0x00000010;
      lat = 0L;
      return this;
    }

    public long getLat() {
      return lat;
    }

    public Node setLat(final long value) {
      bitField0_ |= 0x00000010;
      lat = value;
      return this;
    }

    public boolean hasLon() {
      return (bitField0_ & 0x00000020) != 0;
    }

    public Node clearLon() {
      bitField0_ &= ~0x00000020;
      lon = 0L;
      return this;
    }

    public long getLon() {
      return lon;
    }

    public Node setLon(final long value) {
      bitField0_ |= 0x00000020;
      lon = value;
      return this;
    }

    public boolean hasInfo() {
      return (bitField0_ & 0x00000001) != 0;
    }

    public Node clearInfo() {
      bitField0_ &= ~0x00000001;
      info.clear();
      return this;
    }

    /**
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableInfo()} if you want to modify it.
     */
    public Info getInfo() {
      return info;
    }

    /**
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     */
    public Info getMutableInfo() {
      bitField0_ |= 0x00000001;
      return info;
    }

    public Node setInfo(final Info value) {
      bitField0_ |= 0x00000001;
      info.copyFrom(value);
      return this;
    }

    public boolean hasKeys() {
      return (bitField0_ & 0x00000002) != 0;
    }

    public Node clearKeys() {
      bitField0_ &= ~0x00000002;
      keys.clear();
      return this;
    }

    /**
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableKeys()} if you want to modify it.
     */
    public RepeatedInt getKeys() {
      return keys;
    }

    /**
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     */
    public RepeatedInt getMutableKeys() {
      bitField0_ |= 0x00000002;
      return keys;
    }

    public Node addKeys(final int value) {
      bitField0_ |= 0x00000002;
      keys.add(value);
      return this;
    }

    public Node addAllKeys(final int... values) {
      bitField0_ |= 0x00000002;
      keys.addAll(values);
      return this;
    }

    public boolean hasVals() {
      return (bitField0_ & 0x00000004) != 0;
    }

    public Node clearVals() {
      bitField0_ &= ~0x00000004;
      vals.clear();
      return this;
    }

    /**
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableVals()} if you want to modify it.
     */
    public RepeatedInt getVals() {
      return vals;
    }

    /**
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     */
    public RepeatedInt getMutableVals() {
      bitField0_ |= 0x00000004;
      return vals;
    }

    public Node addVals(final int value) {
      bitField0_ |= 0x00000004;
      vals.add(value);
      return this;
    }

    public Node addAllVals(final int... values) {
      bitField0_ |= 0x00000004;
      vals.addAll(values);
      return this;
    }

    @Override
    public Node copyFrom(final Node other) {
      cachedSize = other.cachedSize;
      if ((bitField0_ | other.bitField0_) != 0) {
        bitField0_ = other.bitField0_;
        id = other.id;
        lat = other.lat;
        lon = other.lon;
        info.copyFrom(other.info);
        keys.copyFrom(other.keys);
        vals.copyFrom(other.vals);
      }
      return this;
    }

    @Override
    public Node mergeFrom(final Node other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      if (other.hasId()) {
        setId(other.id);
      }
      if (other.hasLat()) {
        setLat(other.lat);
      }
      if (other.hasLon()) {
        setLon(other.lon);
      }
      if (other.hasInfo()) {
        getMutableInfo().mergeFrom(other.info);
      }
      if (other.hasKeys()) {
        getMutableKeys().addAll(other.keys);
      }
      if (other.hasVals()) {
        getMutableVals().addAll(other.vals);
      }
      return this;
    }

    @Override
    public Node clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      id = 0L;
      lat = 0L;
      lon = 0L;
      info.clear();
      keys.clear();
      vals.clear();
      return this;
    }

    @Override
    public Node clearQuick() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      info.clearQuick();
      keys.clear();
      vals.clear();
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof Node)) {
        return false;
      }
      Node other = (Node) o;
      return bitField0_ == other.bitField0_
        && (!hasId() || id == other.id)
        && (!hasLat() || lat == other.lat)
        && (!hasLon() || lon == other.lon)
        && (!hasInfo() || info.equals(other.info))
        && (!hasKeys() || keys.equals(other.keys))
        && (!hasVals() || vals.equals(other.vals));
    }

    @Override
    public void writeTo(final ProtoSink output) throws IOException {
      if ((((bitField0_ & 0x00000038) != 0x00000038))) {
        throw new UninitializedMessageException(this);
      }
      try {
        output.writeRawByte((byte) 8);
        output.writeSInt64NoTag(id);
        output.writeRawByte((byte) 64);
        output.writeSInt64NoTag(lat);
        output.writeRawByte((byte) 72);
        output.writeSInt64NoTag(lon);
        if ((bitField0_ & 0x00000001) != 0) {
          output.writeRawByte((byte) 34);
          output.writeMessageNoTag(info);
        }
        if ((bitField0_ & 0x00000002) != 0) {
          output.writeRawByte((byte) 18);
          output.writePackedUInt32NoTag(keys);
        }
        if ((bitField0_ & 0x00000004) != 0) {
          output.writeRawByte((byte) 26);
          output.writePackedUInt32NoTag(vals);
        }
      } catch (UninitializedMessageException nestedFail) {
        throw rethrowFromParent(nestedFail);
      }
    }

    @Override
    protected int computeSerializedSize() {
      if ((((bitField0_ & 0x00000038) != 0x00000038))) {
        throw new UninitializedMessageException(this);
      }
      try {
        int size = 0;
        size += 1 + ProtoSink.computeSInt64SizeNoTag(id);
        size += 1 + ProtoSink.computeSInt64SizeNoTag(lat);
        size += 1 + ProtoSink.computeSInt64SizeNoTag(lon);
        if ((bitField0_ & 0x00000001) != 0) {
          size += 1 + ProtoSink.computeMessageSizeNoTag(info);
        }
        if ((bitField0_ & 0x00000002) != 0) {
          final int dataSize = ProtoSink.computeRepeatedUInt32SizeNoTag(keys);
          size += 1 + ProtoSink.computeDelimitedSize(dataSize);
        }
        if ((bitField0_ & 0x00000004) != 0) {
          final int dataSize = ProtoSink.computeRepeatedUInt32SizeNoTag(vals);
          size += 1 + ProtoSink.computeDelimitedSize(dataSize);
        }
        return size;
      } catch (UninitializedMessageException nestedFail) {
        throw rethrowFromParent(nestedFail);
      }
    }

    @Override
    public Node mergeFrom(final ProtoSource input) throws IOException {
      // Enabled Fall-Through Optimization (QuickBuffers)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 8: {
            id = input.readSInt64();
            bitField0_ |= 0x00000008;
            tag = input.readTag();
            if (tag != 64) {
              break;
            }
          }
          case 64: {
            lat = input.readSInt64();
            bitField0_ |= 0x00000010;
            tag = input.readTag();
            if (tag != 72) {
              break;
            }
          }
          case 72: {
            lon = input.readSInt64();
            bitField0_ |= 0x00000020;
            tag = input.readTag();
            if (tag != 34) {
              break;
            }
          }
          case 34: {
            input.readMessage(info);
            bitField0_ |= 0x00000001;
            tag = input.readTag();
            if (tag != 18) {
              break;
            }
          }
          case 18: {
            input.readPackedUInt32(keys, tag);
            bitField0_ |= 0x00000002;
            tag = input.readTag();
            if (tag != 26) {
              break;
            }
          }
          case 26: {
            input.readPackedUInt32(vals, tag);
            bitField0_ |= 0x00000004;
            tag = input.readTag();
            if (tag != 0) {
              break;
            }
          }
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
          case 16: {
            tag = input.readRepeatedUInt32(keys, tag);
            bitField0_ |= 0x00000002;
            break;
          }
          case 24: {
            tag = input.readRepeatedUInt32(vals, tag);
            bitField0_ |= 0x00000004;
            break;
          }
        }
      }
    }

    @Override
    public final boolean isInitialized() {
      if ((((bitField0_ & 0x00000038) != 0x00000038))) {
        return false;
      }
      return true;
    }

    @Override
    protected final void getMissingFields(String prefix, List<String> results) {
      if (!hasId()) {
        results.add(prefix + "id");
      }
      if (!hasLat()) {
        results.add(prefix + "lat");
      }
      if (!hasLon()) {
        results.add(prefix + "lon");
      }
    }

    @Override
    public void writeTo(final JsonSink output) throws IOException {
      if ((((bitField0_ & 0x00000038) != 0x00000038))) {
        throw new UninitializedMessageException(this);
      }
      try {
        output.beginObject();
        output.writeSInt64(FieldNames.id, id);
        output.writeSInt64(FieldNames.lat, lat);
        output.writeSInt64(FieldNames.lon, lon);
        if ((bitField0_ & 0x00000001) != 0) {
          output.writeMessage(FieldNames.info, info);
        }
        if ((bitField0_ & 0x00000002) != 0) {
          output.writeRepeatedUInt32(FieldNames.keys, keys);
        }
        if ((bitField0_ & 0x00000004) != 0) {
          output.writeRepeatedUInt32(FieldNames.vals, vals);
        }
        output.endObject();
      } catch (UninitializedMessageException nestedFail) {
        throw rethrowFromParent(nestedFail);
      }
    }

    @Override
    public Node mergeFrom(final JsonSource input) throws IOException {
      if (!input.beginObject()) {
        return this;
      }
      while (!input.isAtEnd()) {
        switch (input.readFieldHash()) {
          case 3355: {
            if (input.isAtField(FieldNames.id)) {
              id = input.readSInt64();
              bitField0_ |= 0x00000008;
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 106911: {
            if (input.isAtField(FieldNames.lat)) {
              lat = input.readSInt64();
              bitField0_ |= 0x00000010;
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 107339: {
            if (input.isAtField(FieldNames.lon)) {
              lon = input.readSInt64();
              bitField0_ |= 0x00000020;
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 3237038: {
            if (input.isAtField(FieldNames.info)) {
              input.readMessage(info);
              bitField0_ |= 0x00000001;
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 3288564: {
            if (input.isAtField(FieldNames.keys)) {
              input.readRepeatedUInt32(keys);
              bitField0_ |= 0x00000002;
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 3612018: {
            if (input.isAtField(FieldNames.vals)) {
              input.readRepeatedUInt32(vals);
              bitField0_ |= 0x00000004;
            } else {
              input.skipUnknownField();
            }
            break;
          }
          default: {
            input.skipUnknownField();
            break;
          }
        }
      }
      input.endObject();
      return this;
    }

    @Override
    public Node clone() {
      return new Node().copyFrom(this);
    }

    public boolean isEmpty() {
      return ((bitField0_) == 0);
    }

    public static Node parseFrom(final byte[] data) throws InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new Node(), data).checkInitialized();
    }

    public static Node parseFrom(final ProtoSource input) throws IOException {
      return ProtoMessage.mergeFrom(new Node(), input).checkInitialized();
    }

    public static Node parseFrom(final JsonSource input) throws IOException {
      return ProtoMessage.mergeFrom(new Node(), input).checkInitialized();
    }

    public static MessageFactory<Node> getFactory() {
      return NodeFactory.INSTANCE;
    }

    private enum NodeFactory implements MessageFactory<Node> {
      INSTANCE;

      @Override
      public Node create() {
        return Node.newInstance();
      }
    }

    /**
     * Contains name constants used for serializing JSON
     */
    static class FieldNames {
      static final FieldName id = FieldName.forField("id");

      static final FieldName lat = FieldName.forField("lat");

      static final FieldName lon = FieldName.forField("lon");

      static final FieldName info = FieldName.forField("info");

      static final FieldName keys = FieldName.forField("keys");

      static final FieldName vals = FieldName.forField("vals");
    }
  }

  public static final class DenseNodes extends ProtoMessage<DenseNodes> implements Cloneable {
    private static final long serialVersionUID = 0L;

    /**
     * optional .OSMPBF.DenseInfo denseinfo = 5;
     */
    private final DenseInfo denseinfo = DenseInfo.newInstance();

    /**
     * repeated sint64 id = 1 [packed = true];
     */
    private final RepeatedLong id = RepeatedLong.newEmptyInstance();

    /**
     * repeated sint64 lat = 8 [packed = true];
     */
    private final RepeatedLong lat = RepeatedLong.newEmptyInstance();

    /**
     * repeated sint64 lon = 9 [packed = true];
     */
    private final RepeatedLong lon = RepeatedLong.newEmptyInstance();

    /**
     * repeated int32 keys_vals = 10 [packed = true];
     */
    private final RepeatedInt keysVals = RepeatedInt.newEmptyInstance();

    private DenseNodes() {
    }

    public static DenseNodes newInstance() {
      return new DenseNodes();
    }

    public boolean hasDenseinfo() {
      return (bitField0_ & 0x00000001) != 0;
    }

    public DenseNodes clearDenseinfo() {
      bitField0_ &= ~0x00000001;
      denseinfo.clear();
      return this;
    }

    /**
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableDenseinfo()} if you want to modify it.
     */
    public DenseInfo getDenseinfo() {
      return denseinfo;
    }

    /**
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     */
    public DenseInfo getMutableDenseinfo() {
      bitField0_ |= 0x00000001;
      return denseinfo;
    }

    public DenseNodes setDenseinfo(final DenseInfo value) {
      bitField0_ |= 0x00000001;
      denseinfo.copyFrom(value);
      return this;
    }

    public boolean hasId() {
      return (bitField0_ & 0x00000002) != 0;
    }

    public DenseNodes clearId() {
      bitField0_ &= ~0x00000002;
      id.clear();
      return this;
    }

    /**
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableId()} if you want to modify it.
     */
    public RepeatedLong getId() {
      return id;
    }

    /**
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     */
    public RepeatedLong getMutableId() {
      bitField0_ |= 0x00000002;
      return id;
    }

    public DenseNodes addId(final long value) {
      bitField0_ |= 0x00000002;
      id.add(value);
      return this;
    }

    public DenseNodes addAllId(final long... values) {
      bitField0_ |= 0x00000002;
      id.addAll(values);
      return this;
    }

    public boolean hasLat() {
      return (bitField0_ & 0x00000004) != 0;
    }

    public DenseNodes clearLat() {
      bitField0_ &= ~0x00000004;
      lat.clear();
      return this;
    }

    /**
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableLat()} if you want to modify it.
     */
    public RepeatedLong getLat() {
      return lat;
    }

    /**
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     */
    public RepeatedLong getMutableLat() {
      bitField0_ |= 0x00000004;
      return lat;
    }

    public DenseNodes addLat(final long value) {
      bitField0_ |= 0x00000004;
      lat.add(value);
      return this;
    }

    public DenseNodes addAllLat(final long... values) {
      bitField0_ |= 0x00000004;
      lat.addAll(values);
      return this;
    }

    public boolean hasLon() {
      return (bitField0_ & 0x00000008) != 0;
    }

    public DenseNodes clearLon() {
      bitField0_ &= ~0x00000008;
      lon.clear();
      return this;
    }

    /**
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableLon()} if you want to modify it.
     */
    public RepeatedLong getLon() {
      return lon;
    }

    /**
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     */
    public RepeatedLong getMutableLon() {
      bitField0_ |= 0x00000008;
      return lon;
    }

    public DenseNodes addLon(final long value) {
      bitField0_ |= 0x00000008;
      lon.add(value);
      return this;
    }

    public DenseNodes addAllLon(final long... values) {
      bitField0_ |= 0x00000008;
      lon.addAll(values);
      return this;
    }

    public boolean hasKeysVals() {
      return (bitField0_ & 0x00000010) != 0;
    }

    public DenseNodes clearKeysVals() {
      bitField0_ &= ~0x00000010;
      keysVals.clear();
      return this;
    }

    /**
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableKeysVals()} if you want to modify it.
     */
    public RepeatedInt getKeysVals() {
      return keysVals;
    }

    /**
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     */
    public RepeatedInt getMutableKeysVals() {
      bitField0_ |= 0x00000010;
      return keysVals;
    }

    public DenseNodes addKeysVals(final int value) {
      bitField0_ |= 0x00000010;
      keysVals.add(value);
      return this;
    }

    public DenseNodes addAllKeysVals(final int... values) {
      bitField0_ |= 0x00000010;
      keysVals.addAll(values);
      return this;
    }

    @Override
    public DenseNodes copyFrom(final DenseNodes other) {
      cachedSize = other.cachedSize;
      if ((bitField0_ | other.bitField0_) != 0) {
        bitField0_ = other.bitField0_;
        denseinfo.copyFrom(other.denseinfo);
        id.copyFrom(other.id);
        lat.copyFrom(other.lat);
        lon.copyFrom(other.lon);
        keysVals.copyFrom(other.keysVals);
      }
      return this;
    }

    @Override
    public DenseNodes mergeFrom(final DenseNodes other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      if (other.hasDenseinfo()) {
        getMutableDenseinfo().mergeFrom(other.denseinfo);
      }
      if (other.hasId()) {
        getMutableId().addAll(other.id);
      }
      if (other.hasLat()) {
        getMutableLat().addAll(other.lat);
      }
      if (other.hasLon()) {
        getMutableLon().addAll(other.lon);
      }
      if (other.hasKeysVals()) {
        getMutableKeysVals().addAll(other.keysVals);
      }
      return this;
    }

    @Override
    public DenseNodes clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      denseinfo.clear();
      id.clear();
      lat.clear();
      lon.clear();
      keysVals.clear();
      return this;
    }

    @Override
    public DenseNodes clearQuick() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      denseinfo.clearQuick();
      id.clear();
      lat.clear();
      lon.clear();
      keysVals.clear();
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof DenseNodes)) {
        return false;
      }
      DenseNodes other = (DenseNodes) o;
      return bitField0_ == other.bitField0_
        && (!hasDenseinfo() || denseinfo.equals(other.denseinfo))
        && (!hasId() || id.equals(other.id))
        && (!hasLat() || lat.equals(other.lat))
        && (!hasLon() || lon.equals(other.lon))
        && (!hasKeysVals() || keysVals.equals(other.keysVals));
    }

    @Override
    public void writeTo(final ProtoSink output) throws IOException {
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeRawByte((byte) 42);
        output.writeMessageNoTag(denseinfo);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeRawByte((byte) 10);
        output.writePackedSInt64NoTag(id);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeRawByte((byte) 66);
        output.writePackedSInt64NoTag(lat);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        output.writeRawByte((byte) 74);
        output.writePackedSInt64NoTag(lon);
      }
      if ((bitField0_ & 0x00000010) != 0) {
        output.writeRawByte((byte) 82);
        output.writePackedInt32NoTag(keysVals);
      }
    }

    @Override
    protected int computeSerializedSize() {
      int size = 0;
      if ((bitField0_ & 0x00000001) != 0) {
        size += 1 + ProtoSink.computeMessageSizeNoTag(denseinfo);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        final int dataSize = ProtoSink.computeRepeatedSInt64SizeNoTag(id);
        size += 1 + ProtoSink.computeDelimitedSize(dataSize);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        final int dataSize = ProtoSink.computeRepeatedSInt64SizeNoTag(lat);
        size += 1 + ProtoSink.computeDelimitedSize(dataSize);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        final int dataSize = ProtoSink.computeRepeatedSInt64SizeNoTag(lon);
        size += 1 + ProtoSink.computeDelimitedSize(dataSize);
      }
      if ((bitField0_ & 0x00000010) != 0) {
        final int dataSize = ProtoSink.computeRepeatedInt32SizeNoTag(keysVals);
        size += 1 + ProtoSink.computeDelimitedSize(dataSize);
      }
      return size;
    }

    @Override
    public DenseNodes mergeFrom(final ProtoSource input) throws IOException {
      // Enabled Fall-Through Optimization (QuickBuffers)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 42: {
            input.readMessage(denseinfo);
            bitField0_ |= 0x00000001;
            tag = input.readTag();
            if (tag != 10) {
              break;
            }
          }
          case 10: {
            input.readPackedSInt64(id, tag);
            bitField0_ |= 0x00000002;
            tag = input.readTag();
            if (tag != 66) {
              break;
            }
          }
          case 66: {
            input.readPackedSInt64(lat, tag);
            bitField0_ |= 0x00000004;
            tag = input.readTag();
            if (tag != 74) {
              break;
            }
          }
          case 74: {
            input.readPackedSInt64(lon, tag);
            bitField0_ |= 0x00000008;
            tag = input.readTag();
            if (tag != 82) {
              break;
            }
          }
          case 82: {
            input.readPackedInt32(keysVals, tag);
            bitField0_ |= 0x00000010;
            tag = input.readTag();
            if (tag != 0) {
              break;
            }
          }
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
          case 8: {
            tag = input.readRepeatedSInt64(id, tag);
            bitField0_ |= 0x00000002;
            break;
          }
          case 64: {
            tag = input.readRepeatedSInt64(lat, tag);
            bitField0_ |= 0x00000004;
            break;
          }
          case 72: {
            tag = input.readRepeatedSInt64(lon, tag);
            bitField0_ |= 0x00000008;
            break;
          }
          case 80: {
            tag = input.readRepeatedInt32(keysVals, tag);
            bitField0_ |= 0x00000010;
            break;
          }
        }
      }
    }

    @Override
    public void writeTo(final JsonSink output) throws IOException {
      output.beginObject();
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeMessage(FieldNames.denseinfo, denseinfo);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeRepeatedSInt64(FieldNames.id, id);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeRepeatedSInt64(FieldNames.lat, lat);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        output.writeRepeatedSInt64(FieldNames.lon, lon);
      }
      if ((bitField0_ & 0x00000010) != 0) {
        output.writeRepeatedInt32(FieldNames.keysVals, keysVals);
      }
      output.endObject();
    }

    @Override
    public DenseNodes mergeFrom(final JsonSource input) throws IOException {
      if (!input.beginObject()) {
        return this;
      }
      while (!input.isAtEnd()) {
        switch (input.readFieldHash()) {
          case 1803386957: {
            if (input.isAtField(FieldNames.denseinfo)) {
              input.readMessage(denseinfo);
              bitField0_ |= 0x00000001;
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 3355: {
            if (input.isAtField(FieldNames.id)) {
              input.readRepeatedSInt64(id);
              bitField0_ |= 0x00000002;
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 106911: {
            if (input.isAtField(FieldNames.lat)) {
              input.readRepeatedSInt64(lat);
              bitField0_ |= 0x00000004;
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 107339: {
            if (input.isAtField(FieldNames.lon)) {
              input.readRepeatedSInt64(lon);
              bitField0_ |= 0x00000008;
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 518694278:
          case -1091419939: {
            if (input.isAtField(FieldNames.keysVals)) {
              input.readRepeatedInt32(keysVals);
              bitField0_ |= 0x00000010;
            } else {
              input.skipUnknownField();
            }
            break;
          }
          default: {
            input.skipUnknownField();
            break;
          }
        }
      }
      input.endObject();
      return this;
    }

    @Override
    public DenseNodes clone() {
      return new DenseNodes().copyFrom(this);
    }

    public boolean isEmpty() {
      return ((bitField0_) == 0);
    }

    public static DenseNodes parseFrom(final byte[] data) throws InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new DenseNodes(), data).checkInitialized();
    }

    public static DenseNodes parseFrom(final ProtoSource input) throws IOException {
      return ProtoMessage.mergeFrom(new DenseNodes(), input).checkInitialized();
    }

    public static DenseNodes parseFrom(final JsonSource input) throws IOException {
      return ProtoMessage.mergeFrom(new DenseNodes(), input).checkInitialized();
    }

    public static MessageFactory<DenseNodes> getFactory() {
      return DenseNodesFactory.INSTANCE;
    }

    private enum DenseNodesFactory implements MessageFactory<DenseNodes> {
      INSTANCE;

      @Override
      public DenseNodes create() {
        return DenseNodes.newInstance();
      }
    }

    /**
     * Contains name constants used for serializing JSON
     */
    static class FieldNames {
      static final FieldName denseinfo = FieldName.forField("denseinfo");

      static final FieldName id = FieldName.forField("id");

      static final FieldName lat = FieldName.forField("lat");

      static final FieldName lon = FieldName.forField("lon");

      static final FieldName keysVals = FieldName.forField("keysVals", "keys_vals");
    }
  }

  public static final class Way extends ProtoMessage<Way> implements Cloneable {
    private static final long serialVersionUID = 0L;

    /**
     * required int64 id = 1;
     */
    private long id;

    /**
     * repeated sint64 refs = 8 [packed = true];
     */
    private final RepeatedLong refs = RepeatedLong.newEmptyInstance();

    /**
     * repeated uint32 keys = 2 [packed = true];
     */
    private final RepeatedInt keys = RepeatedInt.newEmptyInstance();

    /**
     * repeated uint32 vals = 3 [packed = true];
     */
    private final RepeatedInt vals = RepeatedInt.newEmptyInstance();

    private Way() {
    }

    public static Way newInstance() {
      return new Way();
    }

    public boolean hasId() {
      return (bitField0_ & 0x00000008) != 0;
    }

    public Way clearId() {
      bitField0_ &= ~0x00000008;
      id = 0L;
      return this;
    }

    public long getId() {
      return id;
    }

    public Way setId(final long value) {
      bitField0_ |= 0x00000008;
      id = value;
      return this;
    }

    public boolean hasRefs() {
      return (bitField0_ & 0x00000001) != 0;
    }

    public Way clearRefs() {
      bitField0_ &= ~0x00000001;
      refs.clear();
      return this;
    }

    /**
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableRefs()} if you want to modify it.
     */
    public RepeatedLong getRefs() {
      return refs;
    }

    /**
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     */
    public RepeatedLong getMutableRefs() {
      bitField0_ |= 0x00000001;
      return refs;
    }

    public Way addRefs(final long value) {
      bitField0_ |= 0x00000001;
      refs.add(value);
      return this;
    }

    public Way addAllRefs(final long... values) {
      bitField0_ |= 0x00000001;
      refs.addAll(values);
      return this;
    }

    public boolean hasKeys() {
      return (bitField0_ & 0x00000002) != 0;
    }

    public Way clearKeys() {
      bitField0_ &= ~0x00000002;
      keys.clear();
      return this;
    }

    /**
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableKeys()} if you want to modify it.
     */
    public RepeatedInt getKeys() {
      return keys;
    }

    /**
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     */
    public RepeatedInt getMutableKeys() {
      bitField0_ |= 0x00000002;
      return keys;
    }

    public Way addKeys(final int value) {
      bitField0_ |= 0x00000002;
      keys.add(value);
      return this;
    }

    public Way addAllKeys(final int... values) {
      bitField0_ |= 0x00000002;
      keys.addAll(values);
      return this;
    }

    public boolean hasVals() {
      return (bitField0_ & 0x00000004) != 0;
    }

    public Way clearVals() {
      bitField0_ &= ~0x00000004;
      vals.clear();
      return this;
    }

    /**
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableVals()} if you want to modify it.
     */
    public RepeatedInt getVals() {
      return vals;
    }

    /**
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     */
    public RepeatedInt getMutableVals() {
      bitField0_ |= 0x00000004;
      return vals;
    }

    public Way addVals(final int value) {
      bitField0_ |= 0x00000004;
      vals.add(value);
      return this;
    }

    public Way addAllVals(final int... values) {
      bitField0_ |= 0x00000004;
      vals.addAll(values);
      return this;
    }

    @Override
    public Way copyFrom(final Way other) {
      cachedSize = other.cachedSize;
      if ((bitField0_ | other.bitField0_) != 0) {
        bitField0_ = other.bitField0_;
        id = other.id;
        refs.copyFrom(other.refs);
        keys.copyFrom(other.keys);
        vals.copyFrom(other.vals);
      }
      return this;
    }

    @Override
    public Way mergeFrom(final Way other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      if (other.hasId()) {
        setId(other.id);
      }
      if (other.hasRefs()) {
        getMutableRefs().addAll(other.refs);
      }
      if (other.hasKeys()) {
        getMutableKeys().addAll(other.keys);
      }
      if (other.hasVals()) {
        getMutableVals().addAll(other.vals);
      }
      return this;
    }

    @Override
    public Way clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      id = 0L;
      refs.clear();
      keys.clear();
      vals.clear();
      return this;
    }

    @Override
    public Way clearQuick() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      refs.clear();
      keys.clear();
      vals.clear();
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof Way)) {
        return false;
      }
      Way other = (Way) o;
      return bitField0_ == other.bitField0_
        && (!hasId() || id == other.id)
        && (!hasRefs() || refs.equals(other.refs))
        && (!hasKeys() || keys.equals(other.keys))
        && (!hasVals() || vals.equals(other.vals));
    }

    @Override
    public void writeTo(final ProtoSink output) throws IOException {
      if ((((bitField0_ & 0x00000008) != 0x00000008))) {
        throw new UninitializedMessageException(this);
      }
      try {
        output.writeRawByte((byte) 8);
        output.writeInt64NoTag(id);
        if ((bitField0_ & 0x00000001) != 0) {
          output.writeRawByte((byte) 66);
          output.writePackedSInt64NoTag(refs);
        }
        if ((bitField0_ & 0x00000002) != 0) {
          output.writeRawByte((byte) 18);
          output.writePackedUInt32NoTag(keys);
        }
        if ((bitField0_ & 0x00000004) != 0) {
          output.writeRawByte((byte) 26);
          output.writePackedUInt32NoTag(vals);
        }
      } catch (UninitializedMessageException nestedFail) {
        throw rethrowFromParent(nestedFail);
      }
    }

    @Override
    protected int computeSerializedSize() {
      if ((((bitField0_ & 0x00000008) != 0x00000008))) {
        throw new UninitializedMessageException(this);
      }
      try {
        int size = 0;
        size += 1 + ProtoSink.computeInt64SizeNoTag(id);
        if ((bitField0_ & 0x00000001) != 0) {
          final int dataSize = ProtoSink.computeRepeatedSInt64SizeNoTag(refs);
          size += 1 + ProtoSink.computeDelimitedSize(dataSize);
        }
        if ((bitField0_ & 0x00000002) != 0) {
          final int dataSize = ProtoSink.computeRepeatedUInt32SizeNoTag(keys);
          size += 1 + ProtoSink.computeDelimitedSize(dataSize);
        }
        if ((bitField0_ & 0x00000004) != 0) {
          final int dataSize = ProtoSink.computeRepeatedUInt32SizeNoTag(vals);
          size += 1 + ProtoSink.computeDelimitedSize(dataSize);
        }
        return size;
      } catch (UninitializedMessageException nestedFail) {
        throw rethrowFromParent(nestedFail);
      }
    }

    @Override
    public Way mergeFrom(final ProtoSource input) throws IOException {
      // Enabled Fall-Through Optimization (QuickBuffers)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 8: {
            id = input.readInt64();
            bitField0_ |= 0x00000008;
            tag = input.readTag();
            if (tag != 66) {
              break;
            }
          }
          case 66: {
            input.readPackedSInt64(refs, tag);
            bitField0_ |= 0x00000001;
            tag = input.readTag();
            if (tag != 18) {
              break;
            }
          }
          case 18: {
            input.readPackedUInt32(keys, tag);
            bitField0_ |= 0x00000002;
            tag = input.readTag();
            if (tag != 26) {
              break;
            }
          }
          case 26: {
            input.readPackedUInt32(vals, tag);
            bitField0_ |= 0x00000004;
            tag = input.readTag();
            if (tag != 0) {
              break;
            }
          }
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
          case 64: {
            tag = input.readRepeatedSInt64(refs, tag);
            bitField0_ |= 0x00000001;
            break;
          }
          case 16: {
            tag = input.readRepeatedUInt32(keys, tag);
            bitField0_ |= 0x00000002;
            break;
          }
          case 24: {
            tag = input.readRepeatedUInt32(vals, tag);
            bitField0_ |= 0x00000004;
            break;
          }
        }
      }
    }

    @Override
    public final boolean isInitialized() {
      if ((((bitField0_ & 0x00000008) != 0x00000008))) {
        return false;
      }
      return true;
    }

    @Override
    protected final void getMissingFields(String prefix, List<String> results) {
      if (!hasId()) {
        results.add(prefix + "id");
      }
    }

    @Override
    public void writeTo(final JsonSink output) throws IOException {
      if ((((bitField0_ & 0x00000008) != 0x00000008))) {
        throw new UninitializedMessageException(this);
      }
      try {
        output.beginObject();
        output.writeInt64(FieldNames.id, id);
        if ((bitField0_ & 0x00000001) != 0) {
          output.writeRepeatedSInt64(FieldNames.refs, refs);
        }
        if ((bitField0_ & 0x00000002) != 0) {
          output.writeRepeatedUInt32(FieldNames.keys, keys);
        }
        if ((bitField0_ & 0x00000004) != 0) {
          output.writeRepeatedUInt32(FieldNames.vals, vals);
        }
        output.endObject();
      } catch (UninitializedMessageException nestedFail) {
        throw rethrowFromParent(nestedFail);
      }
    }

    @Override
    public Way mergeFrom(final JsonSource input) throws IOException {
      if (!input.beginObject()) {
        return this;
      }
      while (!input.isAtEnd()) {
        switch (input.readFieldHash()) {
          case 3355: {
            if (input.isAtField(FieldNames.id)) {
              id = input.readInt64();
              bitField0_ |= 0x00000008;
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 3496512: {
            if (input.isAtField(FieldNames.refs)) {
              input.readRepeatedSInt64(refs);
              bitField0_ |= 0x00000001;
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 3288564: {
            if (input.isAtField(FieldNames.keys)) {
              input.readRepeatedUInt32(keys);
              bitField0_ |= 0x00000002;
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 3612018: {
            if (input.isAtField(FieldNames.vals)) {
              input.readRepeatedUInt32(vals);
              bitField0_ |= 0x00000004;
            } else {
              input.skipUnknownField();
            }
            break;
          }
          default: {
            input.skipUnknownField();
            break;
          }
        }
      }
      input.endObject();
      return this;
    }

    @Override
    public Way clone() {
      return new Way().copyFrom(this);
    }

    public boolean isEmpty() {
      return ((bitField0_) == 0);
    }

    public static Way parseFrom(final byte[] data) throws InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new Way(), data).checkInitialized();
    }

    public static Way parseFrom(final ProtoSource input) throws IOException {
      return ProtoMessage.mergeFrom(new Way(), input).checkInitialized();
    }

    public static Way parseFrom(final JsonSource input) throws IOException {
      return ProtoMessage.mergeFrom(new Way(), input).checkInitialized();
    }

    public static MessageFactory<Way> getFactory() {
      return WayFactory.INSTANCE;
    }

    private enum WayFactory implements MessageFactory<Way> {
      INSTANCE;

      @Override
      public Way create() {
        return Way.newInstance();
      }
    }

    /**
     * Contains name constants used for serializing JSON
     */
    static class FieldNames {
      static final FieldName id = FieldName.forField("id");

      static final FieldName refs = FieldName.forField("refs");

      static final FieldName keys = FieldName.forField("keys");

      static final FieldName vals = FieldName.forField("vals");
    }
  }

  public static final class Relation extends ProtoMessage<Relation> implements Cloneable {
    private static final long serialVersionUID = 0L;

    /**
     * required int64 id = 1;
     */
    private long id;

    /**
     * optional .OSMPBF.Info info = 4;
     */
    private final Info info = Info.newInstance();

    /**
     * repeated sint64 memids = 9 [packed = true];
     */
    private final RepeatedLong memids = RepeatedLong.newEmptyInstance();

    /**
     * repeated int32 roles_sid = 8 [packed = true];
     */
    private final RepeatedInt rolesSid = RepeatedInt.newEmptyInstance();

    /**
     * repeated uint32 keys = 2 [packed = true];
     */
    private final RepeatedInt keys = RepeatedInt.newEmptyInstance();

    /**
     * repeated uint32 vals = 3 [packed = true];
     */
    private final RepeatedInt vals = RepeatedInt.newEmptyInstance();

    /**
     * repeated .OSMPBF.Relation.MemberType types = 10 [packed = true];
     */
    private final RepeatedEnum<MemberType> types = RepeatedEnum.newEmptyInstance(MemberType.converter());

    private Relation() {
    }

    public static Relation newInstance() {
      return new Relation();
    }

    public boolean hasId() {
      return (bitField0_ & 0x00000040) != 0;
    }

    public Relation clearId() {
      bitField0_ &= ~0x00000040;
      id = 0L;
      return this;
    }

    public long getId() {
      return id;
    }

    public Relation setId(final long value) {
      bitField0_ |= 0x00000040;
      id = value;
      return this;
    }

    public boolean hasInfo() {
      return (bitField0_ & 0x00000001) != 0;
    }

    public Relation clearInfo() {
      bitField0_ &= ~0x00000001;
      info.clear();
      return this;
    }

    /**
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableInfo()} if you want to modify it.
     */
    public Info getInfo() {
      return info;
    }

    /**
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     */
    public Info getMutableInfo() {
      bitField0_ |= 0x00000001;
      return info;
    }

    public Relation setInfo(final Info value) {
      bitField0_ |= 0x00000001;
      info.copyFrom(value);
      return this;
    }

    public boolean hasMemids() {
      return (bitField0_ & 0x00000002) != 0;
    }

    public Relation clearMemids() {
      bitField0_ &= ~0x00000002;
      memids.clear();
      return this;
    }

    /**
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableMemids()} if you want to modify it.
     */
    public RepeatedLong getMemids() {
      return memids;
    }

    /**
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     */
    public RepeatedLong getMutableMemids() {
      bitField0_ |= 0x00000002;
      return memids;
    }

    public Relation addMemids(final long value) {
      bitField0_ |= 0x00000002;
      memids.add(value);
      return this;
    }

    public Relation addAllMemids(final long... values) {
      bitField0_ |= 0x00000002;
      memids.addAll(values);
      return this;
    }

    public boolean hasRolesSid() {
      return (bitField0_ & 0x00000004) != 0;
    }

    public Relation clearRolesSid() {
      bitField0_ &= ~0x00000004;
      rolesSid.clear();
      return this;
    }

    /**
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableRolesSid()} if you want to modify it.
     */
    public RepeatedInt getRolesSid() {
      return rolesSid;
    }

    /**
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     */
    public RepeatedInt getMutableRolesSid() {
      bitField0_ |= 0x00000004;
      return rolesSid;
    }

    public Relation addRolesSid(final int value) {
      bitField0_ |= 0x00000004;
      rolesSid.add(value);
      return this;
    }

    public Relation addAllRolesSid(final int... values) {
      bitField0_ |= 0x00000004;
      rolesSid.addAll(values);
      return this;
    }

    public boolean hasKeys() {
      return (bitField0_ & 0x00000008) != 0;
    }

    public Relation clearKeys() {
      bitField0_ &= ~0x00000008;
      keys.clear();
      return this;
    }

    /**
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableKeys()} if you want to modify it.
     */
    public RepeatedInt getKeys() {
      return keys;
    }

    /**
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     */
    public RepeatedInt getMutableKeys() {
      bitField0_ |= 0x00000008;
      return keys;
    }

    public Relation addKeys(final int value) {
      bitField0_ |= 0x00000008;
      keys.add(value);
      return this;
    }

    public Relation addAllKeys(final int... values) {
      bitField0_ |= 0x00000008;
      keys.addAll(values);
      return this;
    }

    public boolean hasVals() {
      return (bitField0_ & 0x00000010) != 0;
    }

    public Relation clearVals() {
      bitField0_ &= ~0x00000010;
      vals.clear();
      return this;
    }

    /**
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableVals()} if you want to modify it.
     */
    public RepeatedInt getVals() {
      return vals;
    }

    /**
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     */
    public RepeatedInt getMutableVals() {
      bitField0_ |= 0x00000010;
      return vals;
    }

    public Relation addVals(final int value) {
      bitField0_ |= 0x00000010;
      vals.add(value);
      return this;
    }

    public Relation addAllVals(final int... values) {
      bitField0_ |= 0x00000010;
      vals.addAll(values);
      return this;
    }

    public boolean hasTypes() {
      return (bitField0_ & 0x00000020) != 0;
    }

    public Relation clearTypes() {
      bitField0_ &= ~0x00000020;
      types.clear();
      return this;
    }

    /**
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableTypes()} if you want to modify it.
     */
    public RepeatedEnum<MemberType> getTypes() {
      return types;
    }

    /**
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     */
    public RepeatedEnum<MemberType> getMutableTypes() {
      bitField0_ |= 0x00000020;
      return types;
    }

    public Relation addTypes(final MemberType value) {
      bitField0_ |= 0x00000020;
      types.add(value);
      return this;
    }

    public Relation addAllTypes(final MemberType... values) {
      bitField0_ |= 0x00000020;
      types.addAll(values);
      return this;
    }

    @Override
    public Relation copyFrom(final Relation other) {
      cachedSize = other.cachedSize;
      if ((bitField0_ | other.bitField0_) != 0) {
        bitField0_ = other.bitField0_;
        id = other.id;
        info.copyFrom(other.info);
        memids.copyFrom(other.memids);
        rolesSid.copyFrom(other.rolesSid);
        keys.copyFrom(other.keys);
        vals.copyFrom(other.vals);
        types.copyFrom(other.types);
      }
      return this;
    }

    @Override
    public Relation mergeFrom(final Relation other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      if (other.hasId()) {
        setId(other.id);
      }
      if (other.hasInfo()) {
        getMutableInfo().mergeFrom(other.info);
      }
      if (other.hasMemids()) {
        getMutableMemids().addAll(other.memids);
      }
      if (other.hasRolesSid()) {
        getMutableRolesSid().addAll(other.rolesSid);
      }
      if (other.hasKeys()) {
        getMutableKeys().addAll(other.keys);
      }
      if (other.hasVals()) {
        getMutableVals().addAll(other.vals);
      }
      if (other.hasTypes()) {
        getMutableTypes().addAll(other.types);
      }
      return this;
    }

    @Override
    public Relation clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      id = 0L;
      info.clear();
      memids.clear();
      rolesSid.clear();
      keys.clear();
      vals.clear();
      types.clear();
      return this;
    }

    @Override
    public Relation clearQuick() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      info.clearQuick();
      memids.clear();
      rolesSid.clear();
      keys.clear();
      vals.clear();
      types.clear();
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof Relation)) {
        return false;
      }
      Relation other = (Relation) o;
      return bitField0_ == other.bitField0_
        && (!hasId() || id == other.id)
        && (!hasInfo() || info.equals(other.info))
        && (!hasMemids() || memids.equals(other.memids))
        && (!hasRolesSid() || rolesSid.equals(other.rolesSid))
        && (!hasKeys() || keys.equals(other.keys))
        && (!hasVals() || vals.equals(other.vals))
        && (!hasTypes() || types.equals(other.types));
    }

    @Override
    public void writeTo(final ProtoSink output) throws IOException {
      if ((((bitField0_ & 0x00000040) != 0x00000040))) {
        throw new UninitializedMessageException(this);
      }
      try {
        output.writeRawByte((byte) 8);
        output.writeInt64NoTag(id);
        if ((bitField0_ & 0x00000001) != 0) {
          output.writeRawByte((byte) 34);
          output.writeMessageNoTag(info);
        }
        if ((bitField0_ & 0x00000002) != 0) {
          output.writeRawByte((byte) 74);
          output.writePackedSInt64NoTag(memids);
        }
        if ((bitField0_ & 0x00000004) != 0) {
          output.writeRawByte((byte) 66);
          output.writePackedInt32NoTag(rolesSid);
        }
        if ((bitField0_ & 0x00000008) != 0) {
          output.writeRawByte((byte) 18);
          output.writePackedUInt32NoTag(keys);
        }
        if ((bitField0_ & 0x00000010) != 0) {
          output.writeRawByte((byte) 26);
          output.writePackedUInt32NoTag(vals);
        }
        if ((bitField0_ & 0x00000020) != 0) {
          output.writeRawByte((byte) 82);
          output.writePackedEnumNoTag(types);
        }
      } catch (UninitializedMessageException nestedFail) {
        throw rethrowFromParent(nestedFail);
      }
    }

    @Override
    protected int computeSerializedSize() {
      if ((((bitField0_ & 0x00000040) != 0x00000040))) {
        throw new UninitializedMessageException(this);
      }
      try {
        int size = 0;
        size += 1 + ProtoSink.computeInt64SizeNoTag(id);
        if ((bitField0_ & 0x00000001) != 0) {
          size += 1 + ProtoSink.computeMessageSizeNoTag(info);
        }
        if ((bitField0_ & 0x00000002) != 0) {
          final int dataSize = ProtoSink.computeRepeatedSInt64SizeNoTag(memids);
          size += 1 + ProtoSink.computeDelimitedSize(dataSize);
        }
        if ((bitField0_ & 0x00000004) != 0) {
          final int dataSize = ProtoSink.computeRepeatedInt32SizeNoTag(rolesSid);
          size += 1 + ProtoSink.computeDelimitedSize(dataSize);
        }
        if ((bitField0_ & 0x00000008) != 0) {
          final int dataSize = ProtoSink.computeRepeatedUInt32SizeNoTag(keys);
          size += 1 + ProtoSink.computeDelimitedSize(dataSize);
        }
        if ((bitField0_ & 0x00000010) != 0) {
          final int dataSize = ProtoSink.computeRepeatedUInt32SizeNoTag(vals);
          size += 1 + ProtoSink.computeDelimitedSize(dataSize);
        }
        if ((bitField0_ & 0x00000020) != 0) {
          final int dataSize = ProtoSink.computeRepeatedEnumSizeNoTag(types);
          size += 1 + ProtoSink.computeDelimitedSize(dataSize);
        }
        return size;
      } catch (UninitializedMessageException nestedFail) {
        throw rethrowFromParent(nestedFail);
      }
    }

    @Override
    public Relation mergeFrom(final ProtoSource input) throws IOException {
      // Enabled Fall-Through Optimization (QuickBuffers)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 8: {
            id = input.readInt64();
            bitField0_ |= 0x00000040;
            tag = input.readTag();
            if (tag != 34) {
              break;
            }
          }
          case 34: {
            input.readMessage(info);
            bitField0_ |= 0x00000001;
            tag = input.readTag();
            if (tag != 74) {
              break;
            }
          }
          case 74: {
            input.readPackedSInt64(memids, tag);
            bitField0_ |= 0x00000002;
            tag = input.readTag();
            if (tag != 66) {
              break;
            }
          }
          case 66: {
            input.readPackedInt32(rolesSid, tag);
            bitField0_ |= 0x00000004;
            tag = input.readTag();
            if (tag != 18) {
              break;
            }
          }
          case 18: {
            input.readPackedUInt32(keys, tag);
            bitField0_ |= 0x00000008;
            tag = input.readTag();
            if (tag != 26) {
              break;
            }
          }
          case 26: {
            input.readPackedUInt32(vals, tag);
            bitField0_ |= 0x00000010;
            tag = input.readTag();
            if (tag != 82) {
              break;
            }
          }
          case 82: {
            input.readPackedEnum(types, tag);
            bitField0_ |= 0x00000020;
            tag = input.readTag();
            if (tag != 0) {
              break;
            }
          }
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
          case 72: {
            tag = input.readRepeatedSInt64(memids, tag);
            bitField0_ |= 0x00000002;
            break;
          }
          case 64: {
            tag = input.readRepeatedInt32(rolesSid, tag);
            bitField0_ |= 0x00000004;
            break;
          }
          case 16: {
            tag = input.readRepeatedUInt32(keys, tag);
            bitField0_ |= 0x00000008;
            break;
          }
          case 24: {
            tag = input.readRepeatedUInt32(vals, tag);
            bitField0_ |= 0x00000010;
            break;
          }
          case 80: {
            tag = input.readRepeatedEnum(types, tag);
            bitField0_ |= 0x00000020;
            break;
          }
        }
      }
    }

    @Override
    public final boolean isInitialized() {
      if ((((bitField0_ & 0x00000040) != 0x00000040))) {
        return false;
      }
      return true;
    }

    @Override
    protected final void getMissingFields(String prefix, List<String> results) {
      if (!hasId()) {
        results.add(prefix + "id");
      }
    }

    @Override
    public void writeTo(final JsonSink output) throws IOException {
      if ((((bitField0_ & 0x00000040) != 0x00000040))) {
        throw new UninitializedMessageException(this);
      }
      try {
        output.beginObject();
        output.writeInt64(FieldNames.id, id);
        if ((bitField0_ & 0x00000001) != 0) {
          output.writeMessage(FieldNames.info, info);
        }
        if ((bitField0_ & 0x00000002) != 0) {
          output.writeRepeatedSInt64(FieldNames.memids, memids);
        }
        if ((bitField0_ & 0x00000004) != 0) {
          output.writeRepeatedInt32(FieldNames.rolesSid, rolesSid);
        }
        if ((bitField0_ & 0x00000008) != 0) {
          output.writeRepeatedUInt32(FieldNames.keys, keys);
        }
        if ((bitField0_ & 0x00000010) != 0) {
          output.writeRepeatedUInt32(FieldNames.vals, vals);
        }
        if ((bitField0_ & 0x00000020) != 0) {
          output.writeRepeatedEnum(FieldNames.types, types);
        }
        output.endObject();
      } catch (UninitializedMessageException nestedFail) {
        throw rethrowFromParent(nestedFail);
      }
    }

    @Override
    public Relation mergeFrom(final JsonSource input) throws IOException {
      if (!input.beginObject()) {
        return this;
      }
      while (!input.isAtEnd()) {
        switch (input.readFieldHash()) {
          case 3355: {
            if (input.isAtField(FieldNames.id)) {
              id = input.readInt64();
              bitField0_ |= 0x00000040;
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 3237038: {
            if (input.isAtField(FieldNames.info)) {
              input.readMessage(info);
              bitField0_ |= 0x00000001;
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -1077762877: {
            if (input.isAtField(FieldNames.memids)) {
              input.readRepeatedSInt64(memids);
              bitField0_ |= 0x00000002;
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -265690927:
          case 353883212: {
            if (input.isAtField(FieldNames.rolesSid)) {
              input.readRepeatedInt32(rolesSid);
              bitField0_ |= 0x00000004;
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 3288564: {
            if (input.isAtField(FieldNames.keys)) {
              input.readRepeatedUInt32(keys);
              bitField0_ |= 0x00000008;
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 3612018: {
            if (input.isAtField(FieldNames.vals)) {
              input.readRepeatedUInt32(vals);
              bitField0_ |= 0x00000010;
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 110844025: {
            if (input.isAtField(FieldNames.types)) {
              input.readRepeatedEnum(types, MemberType.converter());
              bitField0_ |= 0x00000020;
            } else {
              input.skipUnknownField();
            }
            break;
          }
          default: {
            input.skipUnknownField();
            break;
          }
        }
      }
      input.endObject();
      return this;
    }

    @Override
    public Relation clone() {
      return new Relation().copyFrom(this);
    }

    public boolean isEmpty() {
      return ((bitField0_) == 0);
    }

    public static Relation parseFrom(final byte[] data) throws InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new Relation(), data).checkInitialized();
    }

    public static Relation parseFrom(final ProtoSource input) throws IOException {
      return ProtoMessage.mergeFrom(new Relation(), input).checkInitialized();
    }

    public static Relation parseFrom(final JsonSource input) throws IOException {
      return ProtoMessage.mergeFrom(new Relation(), input).checkInitialized();
    }

    public static MessageFactory<Relation> getFactory() {
      return RelationFactory.INSTANCE;
    }

    public enum MemberType implements ProtoEnum {
      NODE("NODE", 0),

      WAY("WAY", 1),

      RELATION("RELATION", 2);

      public static final int NODE_VALUE = 0;

      public static final int WAY_VALUE = 1;

      public static final int RELATION_VALUE = 2;

      private final String name;

      private final int number;

      private MemberType(String name, int number) {
        this.name = name;
        this.number = number;
      }

      @Override
      public String getName() {
        return name;
      }

      @Override
      public int getNumber() {
        return number;
      }

      public static MemberTypeConverter converter() {
        return MemberTypeConverter.INSTANCE;
      }

      public static MemberType forNumber(int value) {
        return MemberTypeConverter.INSTANCE.forNumber(value);
      }

      public static MemberType forNumberOr(int number, MemberType other) {
        MemberType value = forNumber(number);
        return value == null ? other : value;
      }

      enum MemberTypeConverter implements ProtoEnum.EnumConverter<MemberType> {
        INSTANCE;

        private static final MemberType[] lookup = new MemberType[3];

        static {
          lookup[0] = NODE;
          lookup[1] = WAY;
          lookup[2] = RELATION;
        }

        @Override
        public final MemberType forNumber(final int value) {
          if (value >= 0 && value < lookup.length) {
            return lookup[value];
          }
          return null;
        }

        @Override
        public final MemberType forName(final CharSequence value) {
          if (value.length() == 3) {
            if (ProtoUtil.isEqual("WAY", value)) {
              return WAY;
            }
          }
          if (value.length() == 4) {
            if (ProtoUtil.isEqual("NODE", value)) {
              return NODE;
            }
          }
          if (value.length() == 8) {
            if (ProtoUtil.isEqual("RELATION", value)) {
              return RELATION;
            }
          }
          return null;
        }
      }
    }

    private enum RelationFactory implements MessageFactory<Relation> {
      INSTANCE;

      @Override
      public Relation create() {
        return Relation.newInstance();
      }
    }

    /**
     * Contains name constants used for serializing JSON
     */
    static class FieldNames {
      static final FieldName id = FieldName.forField("id");

      static final FieldName info = FieldName.forField("info");

      static final FieldName memids = FieldName.forField("memids");

      static final FieldName rolesSid = FieldName.forField("rolesSid", "roles_sid");

      static final FieldName keys = FieldName.forField("keys");

      static final FieldName vals = FieldName.forField("vals");

      static final FieldName types = FieldName.forField("types");
    }
  }
}
